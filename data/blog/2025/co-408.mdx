---
title: '计算机组成原理'
summary: '计算机组成原理'
date: '2025-08-16'
tags:
  - others
draft: false
images: ['/static/images/blog/2025/co-408/Pasted%20image%2020250717164603.webp']
authors: ['default']
---

---

cssclasses:

- smalli
  number headings: auto, first-level 1, max 6, 1.1

---

# 1 计算机系统概述

## 1.1 计算机硬件

### 1.1.1 冯·诺伊曼机

![](/static/images/blog/2025/co-408/Pasted%20image%2020250716161958.webp)

- 软件和硬件在逻辑上是等效的

冯 · 诺依曼计算机的特点：

1. 计算机由 5 大部件组成
2. 指令和数据以**同等地位**存于存储器，可按地址寻访
3. 指令和数据用二进制表示
4. 指令由**操作码和地址码**组成
5. **存储程序**：冯·诺伊曼提出的概念
6. ==以运算器为中心==
   1. 输入/输出设备与存储器之间的数据传送通过**运算器**完成

### 1.1.2 现代计算机

区别：以**存储器**为中心

![](/static/images/blog/2025/co-408/Pasted%20image%2020250716162502.webp)

硬件：

1. 主机
   1. CPU
      1. 运算器
      2. 控制器
   2. 存储器
      1. 主存
      2. 辅存（属于IO设备）
2. IO设备
   1. 输入
   2. 输出

![](/static/images/blog/2025/co-408/Pasted%20image%2020250716162601.webp)

![](/static/images/blog/2025/co-408/Pasted%20image%2020250716162925.webp)

## 1.2 硬件工作原理

### 1.2.1 主存储器

主存储器：

1. 存储体
2. MAR 地址寄存器
3. MDR 数据寄存器

注意，现代计算机的MAR和MDR已集成在CPU中。
![](/static/images/blog/2025/co-408/Pasted%20image%2020250716163530.webp)

读取写入数据的过程类似存取包裹：

- MAR 存放地址：需要读/取的数据的**地址**
- MDR 存放数据

![](/static/images/blog/2025/co-408/Pasted%20image%2020250716164009.webp)

| MAR位数                          | MDR位数                     |
| -------------------------------- | --------------------------- |
| **地址码长度**，可算存储单元个数 | 存储**字**长                |
| 4位 = $2^4$个存储单元            | 16位 = 1个存储单元存放16bit |

注意：

- 字长是可变的，字节是不变的 = 8bit
- MDR规定存储**字**长，即规定了1个字=16bit

### 1.2.2 运算器

运算器由 ALU、移位器、状态寄存器（PSW）、通用寄存器组 组成。

![](/static/images/blog/2025/co-408/Pasted%20image%2020250716164724.webp)

- **ALU**：算数逻辑单元
  - 核心，其他三个只是寄存器
- ACC：累加寄存器
- MQ：乘商寄存器
- X：**通用**操作数寄存器

### 1.2.3 控制器

![](/static/images/blog/2025/co-408/Pasted%20image%2020250716165141.webp)

- CU：控制单元，核心

### 1.2.4 硬件工作过程

- [1.2.2\_各个硬件的工作原理\_哔哩哔哩\_bilibili](https://www.bilibili.com/video/BV1ps4y1d73V?spm_id_from=333.788.videopod.sections&vd_source=7f5cf2ae748c813cc5d4d6f55495312c&p=5)

![](/static/images/blog/2025/co-408/Pasted%20image%2020250716165612.webp)

每一步过程都类似：

1. **取指令**：
   1. PC to MAR
   2. MDR to IR：取指令到IR
2. **分析指令**：
   1. IR.op to CU：指令的操作码送到 CU，CU分析指令
3. **执行指令**
   1. IR.ad to MAR：指令的地址码送到 MAR
   2. 后续操作看具体的指令

## 1.3 计算机软件

### 1.3.1 两类软件

- **系统软件** 管理计算机系统的硬件资源，向上层应用程序提供服务。
- **应用软件** 按应用场景需要编制成的各种程序，直接为用户提供服务。

### 1.3.2 三个级别的语言

1. 高级语言
2. 汇编语言：用助记符编写，以便记忆
3. 机器语言：计算机**唯一**可以直接执行的语言

- 汇编语言和机器语言都与计算机系统结构有关

三种程序：

- 编译程序/器：将高级语言一次全部翻译为汇编语言/**直接翻译为机器语言**。
- 汇编程序/器：将汇编语言翻译成机器语言。
- **解释**程序/器：高级语言翻译为机器语言（翻译一句执行一句）。

### 1.3.3 软件和硬件的逻辑功能等价性

同一个功能，既可以用硬件实现，也可以用软件实现。

### 1.3.4 指令集体系结构 (ISA)

- Instruction Set Architecture

一台计算机可以支持哪些指令，以及每条指令的作用是什么、每条指令的用法是什么。

### 1.3.5 计算机系统的层次结构

\*\*计算机系统包含：软件 + 硬件
![](/static/images/blog/2025/co-408/Pasted%20image%2020250718141347.webp)

### 1.3.6 工作原理

从 源程序 到 可执行文件 的流程：

1. **编程**：程序员编写 C 语言源程序（如 `hello.c` ）。
2. **预处理**：
   - 工具：预处理器
   - 输入输出：`hello.c` → `hello.i`
   - 为什么是 `.i`：因为预处理器最核心的功能之一就是处理 `#include` 指令，将所有依赖的头文件内容整合到一个文件中
3. **编译**：
   - 工具：编译器
   - 输入输出：`hello.i` → `hello.s`（汇编语言程序 ）
4. **汇编**：
   - 工具：汇编器
   - 输入输出：`hello.s` → `hello.o`（机器语言程序，即目标模块 ）
5. **链接**：
   - 工具：链接器
   - 输入：`hello.o`、其他被引用目标模块（如 `print.o` ）
   - 输出：`hello.exe`（可执行文件）
   - 将多个相关目标模块链接成完整可执行文件

![](/static/images/blog/2025/co-408/Pasted%20image%2020250718141711.webp)

## 1.4 性能指标

### 1.4.1 存储器性能指标

![](/static/images/blog/2025/co-408/Pasted%20image%2020250718142029.webp)

#### 1.4.1.1 字长概念辨析

1. **机器字长**：
   1. 简称字长
   2. 是 CPU 内部用于**整数运算**的**数据通路**的宽度
   3. 等于 CPU 内部的**运算器**位数和**通用寄存器**宽度
   4. 表示 CPU 一次可以处理的最大二进制位数
2. 存储字长：一个存储单元中的二进制位数
3. 指令字长：一个指令字包含的二进制位数

它们必须都是 1 字节的整数倍。

### 1.4.2 CPU性能指标

1. CPU时钟周期
2. CPU主频：

   $$
   \text{CPU主频（时钟频率）} = \frac{1}{\text{CPU时钟周期}}
   $$

3. CPI （Clock cycle Per Instruction）：执行一条指令所需的时钟周期数。

![](/static/images/blog/2025/co-408/Pasted%20image%2020250718142619.webp)

4. IPS：每秒执行多少条指令1. MIPS：每秒执行多少百万条指令

   $$
   IPS = \frac{\text{主频}}{\text{平均}CPI}
   $$

5. FLOPS：每秒执行多少次浮点运算
   - KFLOPS（Kilo）：千，对应 $10^3$
   - MFLOPS（Million）：百万，对应 $10^6$
   - GFLOPS（Giga）：十亿，对应 $10^9$
   - TFLOPS（Tera）：万亿，对应 $10^{12}$
   - PFLOPS（Peta）：千万亿，对应 $10^{15}$，考过这种题，😅
   - EFLOPS（Exa）：百京，对应 $10^{18}$

![](/static/images/blog/2025/co-408/Pasted%20image%2020250718143646.webp)

### 1.4.3 系统整体性能指标

1. 数据通路带宽：数据总线一次所能并行传送的位数
2. 吞吐量：系统在单位时间处理的请求数
3. 响应时间：发送请求到做出响应的时间

动态测试：可以用**基准程序**来测量计算机处理速度

#### 1.4.3.1 辨析

![](/static/images/blog/2025/co-408/Pasted%20image%2020250718151711.webp)

---

# 2 数据的表示和运算

## 2.1 数制与编码

常识：

$$
2^{16} = 65536
$$

$$
2^{15} = 32768
$$

$$
FFFFH = 1 \dots 1 = 65535
$$

### 2.1.1 进位计数制

**基数**：每个数码位所用到的不同符号的个数

- r进制的基数为r

![](/static/images/blog/2025/co-408/Pasted%20image%2020250718152638.webp)

### 2.1.2 进制转换

#### 2.1.2.1 转十进制

按位权

![](/static/images/blog/2025/co-408/Pasted%20image%2020250718152759.webp)

#### 2.1.2.2 二八六转换

符号对应

![](/static/images/blog/2025/co-408/Pasted%20image%2020250718152830.webp)

#### 2.1.2.3 十进制转换

整数部分：短除法
![](/static/images/blog/2025/co-408/Pasted%20image%2020250718153115.webp)

小数部分：乘r取整
![](/static/images/blog/2025/co-408/Pasted%20image%2020250718153317.webp)

拼凑法：
![](/static/images/blog/2025/co-408/Pasted%20image%2020250718153539.webp)

### 2.1.3 真值 机器数

| 真值         | 机器数                 |
| ------------ | ---------------------- |
| +15          | 01111                  |
| 符合人类习惯 | 数字实际存到机器的形式 |

注意，机器数的正负需要被数字化，多加一位0/1表示符号。

- **408中机器数到底是原码还是补码请看题干**

### 2.1.4 定点数

定点数：

- 无符号数：n位无符号数字的范围是 $[0, 2^n-1]$
- 有符号数
  - 原码
  - 反码
  - 补码
  - 移码

#### 2.1.4.1 有符号数的定点表示

![](/static/images/blog/2025/co-408/Pasted%20image%2020250718154904.webp)

#### 2.1.4.2 原码

![](/static/images/blog/2025/co-408/Pasted%20image%2020250718155125.webp)

#### 2.1.4.3 反码

正数的反码 = 原码
负数的反码 = 数值位取反

![](/static/images/blog/2025/co-408/Pasted%20image%2020250718155603.webp)

#### 2.1.4.4 补码

- C语言数据在内存中，以**补码**形式存放

正数的补码 = 原码
负数的补码 = 反码末位+1，**需要进位**

- 补码 to 原码也是同样的操作

1. 补码和移码的 0 只有一种表示形式；而原码和反码有两种 1. 故，补码和移码范围 + 1 2. 补码可以额外表示的数字：1. 注意，10000000没有原码对应的真值，因为原码无法表示 $2^{-7}$
   ![](/static/images/blog/2025/co-408/Pasted%20image%2020250718155938.webp)
2. 补码可以把减法转为加法：
   ![](/static/images/blog/2025/co-408/Pasted%20image%2020250718163325.webp)

补充：

- 由$[x]_{补}$补快速求$[-x_{补}]$的方法：**符号位**、数值位**全部取反**，末位+1

#### 2.1.4.5 移码

移码 = 补码的**符号位取反**

- 移码只能表示整数
- 移码的真值0也只有一种形式
- 表示范围和补码相同

移码可以用于比较大小，从最高位开始，先出现1的数大。

- 移码是单调增，补码是**分两个周期**线性增大（-128~-1 和 0~127）
  ![](/static/images/blog/2025/co-408/Pasted%20image%2020250718160338.webp)

或者加偏置值

### 2.1.5 语言强制转换

short to int：

- 有符号数：**符号扩展**，且不改变真值
- 无符号数：零扩展
  int to short：高位截断

![](/static/images/blog/2025/co-408/Pasted%20image%2020250718170014.webp)

#### 2.1.5.1 零扩展 符号扩展

- 零扩展适用于无符号数，用0扩展高位
- 符号扩展适用与有符号数，用符号位扩展高位

### 2.1.6 逻辑门电路基础

#### 2.1.6.1 逻辑门

![](/static/images/blog/2025/co-408/Pasted%20image%2020250718170616.webp)

补充：n个bit进行异或

- 若有奇数个1则异或结果为1
- 若有偶数个1则异或结果 0

#### 2.1.6.2 公式

![](/static/images/blog/2025/co-408/Pasted%20image%2020250718171654.webp)

#### 2.1.6.3 多路选择器

![](/static/images/blog/2025/co-408/Pasted%20image%2020250718171841.webp)

#### 2.1.6.4 三态门

![](/static/images/blog/2025/co-408/Pasted%20image%2020250718171943.webp)

三态：高电平、低电平、高阻态

- 高阻态 = 断线

## 2.2 运算方法和运算电路

### 2.2.1 加法器

#### 2.2.1.1 串行进位加法器

- 串行进位又称为行波进位
- 但是属于并行加法器，见术语辨析

![](/static/images/blog/2025/co-408/Pasted%20image%2020250804170758.webp)

问题：进位信息串行传递，导致计算速度取决于进位产生和传递速度

#### 2.2.1.2 术语辨析

1. 由于两个输入端允许**并行**输入 n bit，因此这种加法器属于：**并行加法器**
2. 由于进位信息是**串行**产生的，因此从“进位方式”看，这种加法器属于：**串行进位加法器**
3. 综上，很多教材把这种加法器称为：**串行进位**的**并行**加法器

#### 2.2.1.3 并行进位加法器

加入了CLA部件，使得所有进位信息同时产生。

![](/static/images/blog/2025/co-408/Pasted%20image%2020250804171301.webp)

#### 2.2.1.4 带标志位的加法器

![](/static/images/blog/2025/co-408/Pasted%20image%2020250804171728.webp)

- OF（Overflow Flag）溢出标志，用于判断**带符号数**加减运算是否溢出。
  - OF=1 溢出：OF=0 未溢出
  - 也用于表示**有符号/无符号整数乘法**是否溢出
- SF（Sign Flag）符号标志，用于判断**带符号数**加减运算结果的**正负性**。
  - SF=1 结果负：SF=0 结果为正
- ZF（Zero Flag）零标志，用于判断加减运算结果是否为0。
  - ZF=1 表示结果0；ZF=0 表示结果不为0
- CF（Carry Flag）进位/借位标志，用于判断**无符号数**加减运算是否溢出。
  - CF=1 溢出：CF=0 未溢出

### 2.2.2 算数逻辑单元 ALU

![](/static/images/blog/2025/co-408/Pasted%20image%2020250804174620.webp)

CPU

- 控制器
- 运算器
  - ALU
    - 加法器
  - 通用寄存器
  - 状态寄存器 PSW
  - 移位器

ALU是运算器的核心；加法器是ALU的核心。

#### 2.2.2.1 功能

**重点：如果ALU支持 $k$ 种功能，则控制信号位数 $m \geq \lceil \log_{2}k \rceil$**
![](/static/images/blog/2025/co-408/Pasted%20image%2020250804174925.webp)

$$
\text{ALU 运算位数 }n = \text{机器字长}
$$

$$
\text{PSW 程序状态字寄存器} = \text{FR 标志寄存器}
$$

![](/static/images/blog/2025/co-408/Pasted%20image%2020250804175320.webp)

### 2.2.3 定点数的移位

左右移动 $r$ 位 约等于 乘除 $2^r$

#### 2.2.3.1 逻辑移位

用于无符号整数

左移：高位丢弃，低位补零

- 右移类似，但是右移丢弃位 = 1则会**损失精度**
- 溢出判断：丢弃位是否为 1

![](/static/images/blog/2025/co-408/Pasted%20image%2020250804181253.webp)

#### 2.2.3.2 算数移位

用于有符号整数

左移：移动与逻辑移位完全相同，**符号位一起移动**

- 溢出判断不同，改为**判断符号位是否改变**
  ![](/static/images/blog/2025/co-408/Pasted%20image%2020250807163637.webp)

右移高位补充**符号位**，丢弃位 = 1则也会损失精度
![](/static/images/blog/2025/co-408/Pasted%20image%2020250807164006.webp)

### 2.2.4 定点数的加减

原码运算麻烦，一般采用补码运算

#### 2.2.4.1 原码加减

绝对值加减，再处理符号
![](/static/images/blog/2025/co-408/Pasted%20image%2020250807170117.webp)

#### 2.2.4.2 补码加减

1. 减法 = 加负数
2. **符号位直接参与运算**

![](/static/images/blog/2025/co-408/Pasted%20image%2020250807170609.webp)

溢出判断：
![](/static/images/blog/2025/co-408/Pasted%20image%2020250807172240.webp)

由上图易知，溢出情况**看符号位即可**：

1. 上溢：正 + 正 = 负 0 0 1
2. 下溢：负 + 负 = 正 1 1 0

#### 2.2.4.3 模4 和 模2 补码

模4：双符号位
模2：单符号位
![](/static/images/blog/2025/co-408/Pasted%20image%2020250807173135.webp)

### 2.2.5 无符号数的加减

加法：按位相加即可
![](/static/images/blog/2025/co-408/Pasted%20image%2020250807173356.webp)

减法：减数取补码，减法变加法
![](/static/images/blog/2025/co-408/Pasted%20image%2020250807174111.webp)

#### 2.2.5.1 溢出判断

![](/static/images/blog/2025/co-408/Pasted%20image%2020250807174243.webp)

- 考试时，直接按照十进制算一下即可
- 注意，**无符号数是没有负数的**，$127-128 = -1$ 是溢出的！

结合标志位理解：
![](/static/images/blog/2025/co-408/Pasted%20image%2020250807180425.webp)

### 2.2.6 补码加减运算电路

补码加减运算电路实现了无符号数和有符号数的统一，电路只是计算两个二进制串，并不关心是否有符号。

- 对于 OF 标志位，当作**有符号数**理解，判断加/减是否有溢出即可
- 对于 CF 标志位，当作**无符号数**理解，判断加/减是否有进位/借位即可 - 可能涉及有符号数到无符号数的转换，快速方法是 $-x = 2^k-x$
  ![](/static/images/blog/2025/co-408/Pasted%20image%2020250811195515.webp)

当然也可以按公式算，不过就**慢**了。
![](/static/images/blog/2025/co-408/Pasted%20image%2020250811192622.webp)

sub 信号的两点作用：

1. 多路选择器由 sub 信号控制，实现了（减法时）减数取反的操作
2. sub 信号作为 cin （来自低位的进位），实现了取反之后 + 1

![](/static/images/blog/2025/co-408/Pasted%20image%2020250807175359.webp)

注意，加法器的（加数）输入端仅取反，加1操作依靠 cin 的进位（sub信号）

### 2.2.7 无符号整数的乘法

- 王道说明：考纲侧重考察在**整数**的乘除法，而教材以浮点数的乘除法作为引入

![](/static/images/blog/2025/co-408/Pasted%20image%2020250807183851.webp)

#### 2.2.7.1 电路

特殊处理：控制逻辑会先检查两个是否都是 0，如果是则直接结果为 0

循环：
![](/static/images/blog/2025/co-408/Pasted%20image%2020250807203616.webp)

关于乘法溢出判断：

- 实际上，P Y寄存器共 2n 位，而两个 n 位整数乘法结果一定小于 2n，计算过程中是不可能溢出的
- 但是，由于计算机只保留 n 位，所以**结果上可能溢出**
  ![](/static/images/blog/2025/co-408/Pasted%20image%2020250807203652.webp)

溢出实例 及 2 种溢出处理：
![](/static/images/blog/2025/co-408/Pasted%20image%2020250807203947.webp)

注意：

- 有/无符号整数乘法都是用 OF 标志位记录溢出
- 无符号整数乘法时，CF 也会记录

### 2.2.8 有符号整数的乘法

- 简单思路是直接算绝对值，符号位异或
- 王道网课用了纯电路的方式实现
- 这个方法叫**补码一位**乘法，Booth乘法

电路的主要区别是：

1. 在最右侧添加了辅助位，初始为 0
2. ALU 可以执行加减法
3. 改为**算数右移**

另外添加了一个比较繁琐的规则，见左表：
![](/static/images/blog/2025/co-408/Pasted%20image%2020250807205441.webp)

溢出判断：

- 检查高 $n+1$ 位是否完全相同
- 不完全相同则溢出

![](/static/images/blog/2025/co-408/Pasted%20image%2020250807205939.webp)

注意，有/无符号整数乘法都是用 OF 标志位记录溢出。

### 2.2.9 计算机实现乘法电路的三种方式

上一节的电路实现 n bit 无符号数相乘，至少需要 n 个**时钟**。

#### 2.2.9.1 两位乘法

改进方案：可以实现“两位乘法”，每轮处理乘数寄存器Y的末尾2bit，实现，此时仅需 **n/2 个时钟**即可完成运算

- 具体如何实现两位乘法没有深入

![](/static/images/blog/2025/co-408/Pasted%20image%2020250808004224.webp)

#### 2.2.9.2 阵列乘法器

- **快速**乘法器

可以在 **1 个时钟**内完成乘法运算
![](/static/images/blog/2025/co-408/Pasted%20image%2020250808004055.webp)

#### 2.2.9.3 逻辑运算等效

运算速度很慢
![](/static/images/blog/2025/co-408/Pasted%20image%2020250808004557.webp)

#### 2.2.9.4 总结

- 速度：阵列 > ALU移位 > 逻辑等效
- 本节的三种方法，对于有无符号整数都适用

### 2.2.10 无符号整数的除法运算

- **除法异常**包括：商溢出、除数0

#### 2.2.10.1 手算

二进制和十进制差不多，很简单

![](/static/images/blog/2025/co-408/Pasted%20image%2020250808011209.webp)

#### 2.2.10.2 除法电路

被除数作零拓展
![](/static/images/blog/2025/co-408/Pasted%20image%2020250809192635.webp)

特殊情况：

1. 除数 = 0，**异常**停止
2. 被除数 < 除数，商 = 0

具体过程：
![](/static/images/blog/2025/co-408/Pasted%20image%2020250809194208.webp)

- 判断商溢出：看第一位商（**第一轮**特殊处理）
  - 1，则**商溢出异常**，停止
    - 由于默认高4位填充 0，
    - 所以 n 除 n 时（单精度）不可能商溢出，
    - 2n 除 n 时（双精度）可能溢出，
    - 这一点商溢出小节有提到。
  - 0，则这次计算不可能发生溢出
- 有关ALU**加法操作**：
  - 上商 0 的时候，ALU实际上还是做了 $R - Y$ 的操作（发现小于 0 才判断上商 0），所以需要**做一次 $+ Y$ 的操作**，使得余数恢复为正确的值，之后再左移。
  - 所以，ALU实际上的过程和手算的中间余数不一样，手算是人脑判断之后直接 $- 0000$
  - 称作**恢复余数法**

#### 2.2.10.3 商溢出

![](/static/images/blog/2025/co-408/Pasted%20image%2020250809223204.webp)

按被除数 n/2n 分为单双精度

- 双精度可能溢出
- 单精度**不可能**溢出

## 2.3 浮点数

### 2.3.1 IEEE 754

- 二进制浮点数算数标准

C语言的 float（单精度 32bit）、double（双精度 64bit）就是符合 IEEE 754 标准的浮点数格式。

二进制科学计数法

- 引入 符号、尾数、基数、阶码的概念
  ![](/static/images/blog/2025/co-408/Pasted%20image%2020250809225956.webp)

浮点数由 符号、阶码、尾数 组成

- 尾数的位数决定了精度
- 阶码的位数决定了表示范围
  ![](/static/images/blog/2025/co-408/Pasted%20image%2020250809230327.webp)

#### 2.3.1.1 float 的存储

![](/static/images/blog/2025/co-408/Pasted%20image%2020250809231248.webp)

1. 尾数省略了小数点前的 1（但是尾数概念本身包含这个 1），省略是因为这是隐含的，不用浪费空间表示；所以，实际上 23 bit 表示的是 24 bit 的精度。
2. 如何求移码：十进制 + 偏置值，转为二进制

#### 2.3.1.2 double 的存储

基本一致，注意记忆偏置值
![](/static/images/blog/2025/co-408/Pasted%20image%2020250809231924.webp)

#### 2.3.1.3 例题

![](/static/images/blog/2025/co-408/Pasted%20image%2020250809232411.webp)

### 2.3.2 浮点数表示范围

![](/static/images/blog/2025/co-408/Pasted%20image%2020250810003754.webp)

#### 2.3.2.1 特殊状态的浮点数

- 阶码全 0 / 1，视为特殊状态

![](/static/images/blog/2025/co-408/Pasted%20image%2020250809234003.webp)

#### 2.3.2.2 规格化浮点数

- 注意，规格化的阶码不存在全 0 / 1

float 阶码真值表示范围：
![](/static/images/blog/2025/co-408/Pasted%20image%2020250809233922.webp)

float 规格化浮点数表示范围：
![](/static/images/blog/2025/co-408/Pasted%20image%2020250809234504.webp)

- 理解 $2 - 2^{-23}$：$2^{-23}$ 是尾数第23位
- 正负是对称的，注意，表示范围不包括 0

其实从这个图也可以理解：

- 阶码全 1 （127+1）表示无穷大
- 阶码全 0 （-126-1）表示零
- 注意，127、-126是**移码**
  - 移码转换：
    - 127 是 127+127=254；
    - 127+1 是 128+127=255；
    - 255 是 全 1

#### 2.3.2.3 下溢处理

![](/static/images/blog/2025/co-408/Pasted%20image%2020250810000839.webp)

#### 2.3.2.4 非规格化浮点数

临界值要记住，最大最小的数
![](/static/images/blog/2025/co-408/Pasted%20image%2020250810001326.webp)

1. 非规格化表示的阶码固定为 -126
2. 尾数不能为全零
3. 尾数解读为 **0.xxxx** 而不是正常的 1.xxxx

负数同理：
![](/static/images/blog/2025/co-408/Pasted%20image%2020250810001909.webp)

### 2.3.3 浮点数加减运算

浮点数运算的特点：阶码运算和尾数运算分开。

#### 2.3.3.1 对阶

对阶：使两个操作数的小数点对齐，使得两个数的**阶码相同**。

- 一般是 小阶向大阶对齐

对阶会导致尾数右移，为保证精度，应该不丢弃移出的尾数，使其参与尾数运算。

#### 2.3.3.2 规格化

规格化：将尾数改写为 $\pm 1.x x x$ 形式。

1. 右规：尾数右移（小数点左移），阶码 + 1
2. 左规：尾数左移（小数点右移），阶码 - 1

#### 2.3.3.3 舍入

对阶和右规时移出的位会保留，在舍入这一步时做具体的舍去操作。

1. 就近舍入
2. 正/负向舍入
3. 截断法

#### 2.3.3.4 溢出判断

1. 左右规：可能指数下/上溢
2. 尾数舍入：可能尾数溢出，溢出需要通过右规调整，然后又可能指数上溢。

尾数溢出，结果**不一定**溢出。

- 尾数溢出可以通过右规调整，所以不一定溢出
- 当然调整之后可能指数溢出，最终导致溢出
- 结果是否溢出主要看指数溢出

### 2.3.4 数据存储和排列

大端：高字节在低地址
小端：高字节在高地址

- 注意，以字节（2位16进制）为单位
  ![](/static/images/blog/2025/co-408/Pasted%20image%2020250810004536.webp)

边界对齐

- 一般是按字节编址，即一个地址对应一个字节
  ![](/static/images/blog/2025/co-408/Pasted%20image%2020250810004840.webp)

## 2.4 补充：C语言

在 C 语言里，类型的长度（字节数）取决于编译器实现和平台架构，但常见的 32 位、64 位主流平台（如 Windows x86/x64、Linux x86_64、macOS ARM64）大致遵循下面的规律：

| 类型        | 常见字节数（bytes） | 常见位数（bits） | 备注                                                    |
| ----------- | ------------------- | ---------------- | ------------------------------------------------------- |
| `char`      | 1                   | 8                | **保证**是 1 字节（标准规定 `sizeof(char)` 永远是 1）。 |
| `short`     | 2                   | 16               | 最少 16 位（标准只保证 ≥16 位）。                       |
| `int`       | 4                   | 32               | 在现代主流桌面平台几乎都是 32 位。                      |
| `long`      | 4 / 8               | 32 或 64         | Win 平台的 LLP64 模型 vs Unix/Linux 的 LP64 模型。      |
| `long long` | 8                   | 64               | 标准保证 ≥64 位，几乎总是 64 位。                       |
| `float`     | 4                   | 32               | IEEE 754 单精度。                                       |
| `double`    | 8                   | 64               | IEEE 754 双精度。                                       |

# 3 存储系统

## 3.1 存储器概述

![](/static/images/blog/2025/co-408/Pasted%20image%2020250812165932.webp)

- 辅存中的数据需要调入主存后才能被 CPU 访问

主存与辅存：实现了**虚拟存储系统**，解决了主存容量不够的问题

Cache与主存：解决了主存与 CPU 速度不匹配的问题（CPU 速度更快）

### 3.1.1 存取方式

![](/static/images/blog/2025/co-408/Pasted%20image%2020250812170635.webp)

1. 随机存取存储器 RAM：支持随机访问
2. 顺序存取存储器 SAM：只能顺序访问
3. 直接存取存储器 DAM：支持直接选取区域（随机访问），区域内按顺序访问
   1. 磁盘是 DAM
4. 相联存储器 CAM：按照内容检索 或者 地址检索
   1. **快表**是一种相联存储器

### 3.1.2 性能指标

![](/static/images/blog/2025/co-408/Pasted%20image%2020250812171203.webp)

1.  存储容量 $$\text{存储字数} \times \text{字长}$$
2.  单位成本
    $$
    \frac{\text{总成本}}{\text{总容量}}
    $$
3.  存储速度
    $$
    \text{数据传输率} = \frac{\text{数据宽度}}{\text{存储周期}}
    $$
        1. $存储周期 = 存取时间 + 恢复时间$
        2. 数据传输率也称**主存带宽**

## 3.2 主存储器

主存储器是内存，主要有 RAM 和 ROM 两种。

- RAM：易失性，断电后数据丢失
- ROM：非易失性

### 3.2.1 半导体原理

![](/static/images/blog/2025/co-408/Pasted%20image%2020250812195822.webp)

存储字：一次可以读出的 bit 数

存储字长：

- 存储字的长度
- 一个存储单元中的二进制位数
- 一个存储单元中的**存储元**数量

多个存储单元构成存储体/存储矩阵。

### 3.2.2 存储器芯片原理

1. CPU 通过 地址总线 传递地址 to MAR
2. 控制电路 控制 MAR
3. MAR to 译码器
4. 译码器 选择 存储元
5. 存储元 to MDR

![](/static/images/blog/2025/co-408/Pasted%20image%2020250812200912.webp)

- 读写线可能有 1 或者 2 根
- 片选线：选择哪个芯片
  ![](/static/images/blog/2025/co-408/Pasted%20image%2020250812201927.webp)

引脚数量：

- 每个线对应一个引脚
- 读写线可能有 2 根
  ![](/static/images/blog/2025/co-408/Pasted%20image%2020250812202046.webp)

### 3.2.3 寻址

![](/static/images/blog/2025/co-408/Pasted%20image%2020250812202319.webp)

### 3.2.4 DRAM 与 SRAM

RAM 主要有 DRAM、SRAM：

- Static and Dynamic
- 上一节的是 DRAM

DRAM芯片：使用**栅极电容**存储信息，常用作主存
SRAM芯片：使用**双稳态触发器**存储信息，常用作 Cache

- 核心区别：存储元不一样

| 类型特点                 | DRAM（动态RAM）        | SRAM（静态RAM）        |
| ------------------------ | ---------------------- | ---------------------- |
| 存储信息                 | 电容                   | 触发器                 |
| **破坏性**读出           | 是                     | 非                     |
| 读出后需要重写？（再生） | 需要                   | 不用                   |
| 运行速度                 | 慢                     | **快**                 |
| 集成度                   | **高**                 | 低                     |
| 发热量                   | **小**                 | 大                     |
| 存储成本                 | **低**                 | 高                     |
| 易失/非易失性存储器？    | 易失（断电后信息消失） | 易失（断电后信息消失） |
| 需要**刷新**             | 需要                   | 不需要                 |
| 送行列地址               | **分两次送**           | 同时送                 |

- DRAM 分两次送地址是由于地址线复用，使**地址线、地址引脚减半**

#### 3.2.4.1 DRAM 芯片的行列计算

- **重要补充，网课这块不扎实**

假定有一个 $2^n \times b$ 位的 DRAM 芯片，它实际上是一个**存储阵列**

- 芯片中每个存储单元包含 $b$ 位
- 行数 $r$ 和列数 $c$ 满足 $r\times c = 2^n$
  - 由于按行刷新，所以满足 $r \leq c$
  - 尽量使行列数相同
  - 或者有些题会直接给出 $row \times column \times b$ 位的形式

#### 3.2.4.2 DRAM 刷新

为什么 DRAM 需要刷新？
![](/static/images/blog/2025/co-408/Pasted%20image%2020250814184341.webp)

如何刷新：
![](/static/images/blog/2025/co-408/Pasted%20image%2020250814201709.webp)

三种刷新方式：

1. 分散刷新：刷新太频繁
2. 集中刷新：有死区
3. 异步刷新：死区小
   ![](/static/images/blog/2025/co-408/Pasted%20image%2020250814202232.webp)

刷新由存储器独立完成，无需 CPU 介入。

现在的主存已经抛弃了 DRAM，主要使用 SDRAM，例如 ddr4。

#### 3.2.4.3 SDRAM

- SDRAM（Synchronous DRAM）

SDRAM 的工作方式与传统的 DRAM 有很大不同。

- 传统 DRAM 与CPU 之间采用**异步**方式交换数据，CPU 发出地址和控制信号后，经过一段延迟时间，数据才读出或写入。
  - 在这段时间里，CPU 不断采样 DRAM 的完成信号，在没有完成之前，CPU 插入等待状态而不能做其他工作。
- SDRAM 采用**同步**方式

#### 3.2.4.4 行缓冲寄存器

![](/static/images/blog/2025/co-408/Pasted%20image%2020250815203521.webp)

例如，要从图 6-3中 $16×8$ 的DRAM中读出超单元（2,1），内存控制器发送行地址2，如下图a所示。

**DRAM 的响应是将行 2 的整个内容都复制到一个内部行缓冲区**。接下来，内存控制器发送列地址1，如下图b所示。DRAM的响应是从行缓冲区复制出超单元（2,1）中的8位，并把它们发送到内存控制器。

![](https://pic2.zhimg.com/v2-bb76be90414fd48d198491ba55acab49_1440w.jpg)

超单元：多位就是超单元
![](/static/images/blog/2025/co-408/Pasted%20image%2020250815232121.webp)

### 3.2.5 ROM

各种 ROM：

- MROM（**Mask** Read Only Memory）：
  - 厂家按客户需求在芯片生产时写入信息，**不可重写**，可靠性高、灵活性差、生产周期长，适合批量定制。
- PROM（**Programmable** Read Only Memory）：
  - 用户可用专门写入器写入信息，**写一次后不可更改**。
- EPROM（**Erasable** Programmable Read Only Memory）：
  - 允许用户写入信息，之后可擦除数据并**多次重写**；
  - 支持随机存取
  - UVEPROM：用紫外线照射8 - 20分钟擦除**所有**信息
  - EEPROM（也记为E^2PROM）可用“电擦除”方式擦除**特定**的字。
- Flash Memory（闪速存储器、闪存）：
  - **U盘、SD卡属于闪存**，由EEPROM发展而来，断电能保存信息且可多次快速擦除重写
  - 每个存储元只需单个MOS管，位密度比RAM高，闪存“写”速度比“读”速度慢；
  - 手机辅存使用Flash芯片，不过相比SSD使用的芯片，集成度低、功耗高、价格便宜。
- SSD（Solid State Drives）：
  - 由控制单元 + 存储单元（Flash芯片）构成，与闪存核心区别在控制单元，存储介质类似，可多次快速擦除重写，速度快、功耗低、价格高，
  - 常用于个人电脑手机

计算机内的 RAM 和 ROM：
![](/static/images/blog/2025/co-408/Pasted%20image%2020250814203857.webp)

- 操作系统在辅存（ROM）
- BIOS 属于 ROM
- RAM 和 ROM 一般统一编址，如图所示

### 3.2.6 双端口 RAM

![](/static/images/blog/2025/co-408/Pasted%20image%2020250814204336.webp)

![](/static/images/blog/2025/co-408/Pasted%20image%2020250814204557.webp)

- 作用：优化**多核**CPU访问**一根**内存条的速度。
- 硬件要求：需要有两组完全独立的数据线、地址线、控制线，CPU、RAM中也要有更复杂的控制电路。

两个端口对同一主存操作的4种情况：

1. 两个端口同时对不同的地址单元存取数据。
2. 两个端口同时对同一地址单元读出数据。
3. 两个端口同时对同一地址单元写入数据，会出现**写入错误**。
4. 两个端口同时对同一地址单元，一个写入数据，另一个读出数据，会出现**读出错误**。

### 3.2.7 多模块存储器

多模块存储器主要有：多体并行存储器 和 单体多字存储器。

重要概念：

- **多模块交叉编址**
  - 多模块交叉编址是将一个大的存储空间分成多个小的存储模块，并将这些模块按照一定的规则进行编址，使得在访问连续的存储单元时，可以访问到不同的模块，从而实现**并行访问**。
- **轮流启动**
  - 在轮流启动方式下，系统会按照一定的时间间隔（一个存储器周期）依次启动各个存储模块，进行读写操作。这种方式适用于每个存储模块一次读写的位数（一个存储字）正好等于系统总线数据线位数的情况。
- **同时启动**
  - 在同时启动方式下，所有存储模块会同时启动，进行读写操作。这种方式适用于**所有存储模块一次并行读写的总位数正好等于系统总线数据线位数**的情况。
    - 2022真题：存储器总线宽度 恰好等于 所有模块的总位数，可以判断采用了多模块交叉编址 且 采用了同时启动的方式。

#### 3.2.7.1 多体并行存储器

高位 / 低位交叉编址：
![](/static/images/blog/2025/co-408/Pasted%20image%2020250814205132.webp)

- 存取周期 $T = 4r$ 分为 $存取时间 r + 等待时间(恢复)3r$

**高位交叉**由于连续访问的地址都在**同一条**内存，所以每次存取完都需要等待 $3r$

- **理论上多个存储体可以被并行访问**，但是由于通常会连续访问，因此高位交叉实际效果相当于单纯的扩容，所以一般不用高位

**低位交叉**的等待和存取在不同内存条，所以不冲突，可以实现**并行访问**

流水线方式：
![](/static/images/blog/2025/co-408/Pasted%20image%2020250814205833.webp)

- 注意，存取时间 = 总线传输周期

#### 3.2.7.2 单体多字存储器

只能一次并行读取 m 个字，灵活性差
![](/static/images/blog/2025/co-408/Pasted%20image%2020250814210222.webp)

## 3.3 主存储器与CPU的连接

存储器的输入输出信号：
![](/static/images/blog/2025/co-408/Pasted%20image%2020250814214327.webp)

### 3.3.1 位扩展

两块存储芯片：
![](/static/images/blog/2025/co-408/Pasted%20image%2020250814214421.webp)

扩展到 n 块：
![](/static/images/blog/2025/co-408/Pasted%20image%2020250814214245.webp)

### 3.3.2 字扩展

![](/static/images/blog/2025/co-408/Pasted%20image%2020250814214640.webp)

- 用 A13、14 两位作为片选信号，选择读取指定的芯片

使用1-2 译码器改进：
![](/static/images/blog/2025/co-408/Pasted%20image%2020250814214953.webp)

- 原来需要占用 2 位作为片选信号，现在只需要 **1 位**（A13）
  - 在地址中只占用 1 位（最高位）
- **译码片选法**的核心就是 $n \text{ to } 2^n$
- 注意：
  - 图中 1-2 译码器的输入有一个非门，为了避免产生相同信号（导致同时读）
  - 图中可以看到地址除最高位外，还有 13 位，对应 A0 ~ A12 这 13 位地址

3-8 译码器：
![](/static/images/blog/2025/co-408/Pasted%20image%2020250814215933.webp)

|            | 线选法             | 译码片选法             |
| ---------- | ------------------ | ---------------------- |
| 选片信号   | n 条线 n个选片信号 | n条线 $2^n$ 个选片信号 |
| 电路复杂度 | 电路简单           | 电路复杂               |
| 地址空间   | 地址空间不连续     | **地址空间连续**       |

### 3.3.3 字位同时扩展

2个四位存储器芯片叠一起 作为 位扩展，四组叠叠乐 形成 字扩展。
![](/static/images/blog/2025/co-408/Pasted%20image%2020250814220208.webp)

地址如下：
![](/static/images/blog/2025/co-408/Pasted%20image%2020250815001255.webp)

## 3.4 外部存储器

![](/static/images/blog/2025/co-408/Pasted%20image%2020250815002219.webp)

### 3.4.1 磁盘的组成

磁头、柱面、扇区：
![](/static/images/blog/2025/co-408/Pasted%20image%2020250815002602.webp)

### 3.4.2 磁盘的性能指标

#### 3.4.2.1 磁盘的容量

1. 一个磁盘所能存储的字节总数称为磁盘容量。磁盘容量有非格式化容量和格式化容量之分。
   1. 非格式化容量是指磁记录表面可以利用的磁化单元总数。
   2. 格式化容量是指按照某种特定的记录格式所能存储信息的总量。

#### 3.4.2.2 记录密度

记录密度是指盘片单位面积上记录的二进制的信息量，通常以道密度、位密度和面密度表示。

1. **道密度**是沿磁盘半径方向单位长度上的磁道数；
2. **位密度**是磁道单位长度上能记录的二进制代码位数；
   1. 越内侧的磁道，位密度越大
3. **面密度**是 位密度 和 道密度 的乘积。
   1. 注意：磁盘所有磁道记录的信息量一定是相等的，并不是圆越大信息越多，故每个磁道的位密度都不同。

![](/static/images/blog/2025/co-408/Pasted%20image%2020250815162826.webp)

#### 3.4.2.3 平均存取时间

![](/static/images/blog/2025/co-408/Pasted%20image%2020250815163042.webp)

#### 3.4.2.4 数据传输率

磁盘存储器在单位时间内向主机传送数据的字节数，称为数据传输率。

假设磁盘转数为 $r$（转/秒），每条磁道容量为 $N$ 个字节，则数据传输率为 $D_{r} = rN$

### 3.4.3 磁盘地址

![](/static/images/blog/2025/co-408/Pasted%20image%2020250815163742.webp)

### 3.4.4 磁盘工作过程

硬盘的主要操作是寻址、读盘、写盘。每个操作都对应一个控制字，硬盘工作时，第一步是取控制字，第二步是执行控制字。

硬盘属于机械式部件，其读写操作是**串行**的，**不可能在同一时刻既读又写**，也不可能在同一时刻读两组数据或写两组数据。

#### 3.4.4.1 改进：磁盘阵列

和低位交叉的思想类似，实现并行访问
![](/static/images/blog/2025/co-408/Pasted%20image%2020250815164113.webp)

- RAID0 把连续多个数据块交替地存放在不同物理磁盘的扇区中，几个磁盘交叉并行读写，不仅扩大了存储容量，而且提高了磁盘数据存取速度
  - 但 RAID0 **没有容错能力**。
- RAID1 是为了提高可靠性，使两个磁盘同时进行读写，互为备份，提供了**容错**。
  - 但是两个磁盘完全一致，意味着总容量减少一半，成本大。
- 之后 RAID 通过数据校验，保证安全性，且级数越大，冗余信息越少，成本越低。

### 3.4.5 固态硬盘

原理：基于闪存技术（Flash Memory），属于电可擦除ROM（即EEPROM）。

组成：

1. 有闪存翻译层（负责翻译逻辑块号，找到对应页）
2. 存储介质为多个闪存芯片
   1. 每个芯片含多个块，每个块含多个页。

![](/static/images/blog/2025/co-408/Pasted%20image%2020250815171648.webp)

SSD 的读写是以 页 为单位的，而磁盘是以 扇区为单位。

- SSD 的若干页组成的一个块，相当于磁盘中的一个磁道

读写性能特性：

- 以**页**为单位读/写（相当于磁盘“扇区”）；
- 以**块**为单位擦除，擦干净的块中每页可写一次、读无限次；
- 支持随机访问，能通过电路由逻辑地址迅速定位物理地址；
- 读快、**写慢**
  - 如果写的页若有数据，由于写入需要擦除一整块的数据，所以需将块内其他页复制到新擦除块后，再写入新页
  - 同时，闪存翻译层会把地址映射到新的块

与机械硬盘相比的特点：

- 读写速度快、随机访问性能高，靠电路控制访问位置
  - 机械硬盘靠移动磁臂和旋转磁盘，有寻道时间和旋转延迟
- 安静无噪音、耐摔抗震、能耗低但造价更贵
- SSD的“块”擦除次数过多可能损坏，机械硬盘扇区不会因写次数多损坏。

**磨损均衡**技术：

- 思想是将“擦除”平均分布在各块以**提升使用寿命**
- **动态**磨损均衡是写入数据时**优先选累计擦除次数少**的新闪存块
- **静态**磨损均衡是SSD监测并自动进行数据分配、迁移，让**老闪存块承担以读为主**的存储任务，较新闪存块承担更多写任务。

## 3.5 高速缓冲存储器 Cache

## 3.6 虚拟存储器

# 4 指令系统

## 4.1 指令系统概述

## 4.2 寻址方式

## 4.3 机器代码

## 4.4 CISC 和 RISC

# 5 中央处理器 CPU

## 5.1 CPU概述

## 5.2 指令执行

## 5.3 数据通路

## 5.4 控制器

## 5.5 异常和中断

## 5.6 指令流水线

## 5.7 多处理器

# 6 总线

## 6.1 总线概述

## 6.2 总线事务和定时

# 7 IO系统

## 7.1 IO接口

## 7.2 IO方式

![](/static/images/blog/2025/co-408/Pasted%20image%2020250717164603.webp)
