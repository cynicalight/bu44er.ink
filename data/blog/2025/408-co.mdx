---
title: '计算机组成原理'
summary: '计算机组成原理'
date: '2025-08-31'
tags:
  - cs
draft: false
images: ['/static/images/blog/2025/408-co/Pasted%20image%2020250717164603.webp']
authors: ['default']
---

# 1 计算机系统概述

## 1.1 计算机硬件

### 1.1.1 冯·诺伊曼机

![](/static/images/blog/2025/408-co/Pasted%20image%2020250716161958.webp)

- 软件和硬件在逻辑上是等效的

冯 · 诺依曼计算机的特点：

1. 计算机由 5 大部件组成
2. 指令和数据以**同等地位**存于存储器，可按地址寻访
3. 指令和数据用二进制表示
4. 指令由**操作码和地址码**组成
5. **存储程序**：冯·诺伊曼提出的概念
6. ==以运算器为中心==
   1. 输入/输出设备与存储器之间的数据传送通过**运算器**完成

### 1.1.2 现代计算机

区别：以**存储器**为中心

![](/static/images/blog/2025/408-co/Pasted%20image%2020250716162502.webp)

硬件：

1. 主机
   1. CPU
      1. 运算器
      2. 控制器
   2. 存储器
      1. 主存
      2. 辅存（属于IO设备）
2. IO设备
   1. 输入
   2. 输出

![](/static/images/blog/2025/408-co/Pasted%20image%2020250716162601.webp)

![](/static/images/blog/2025/408-co/Pasted%20image%2020250716162925.webp)

## 1.2 硬件工作原理

### 1.2.1 主存储器

主存储器：

1. 存储体
2. 存储器地址寄存器 MAR
3. 存储器数据寄存器 MDR

注意，现代计算机的MAR和MDR已集成在CPU中。
![](/static/images/blog/2025/408-co/Pasted%20image%2020250716163530.webp)

读取写入数据的过程类似存取包裹：

- MAR 存放地址：需要读/取的数据的**地址**
- MDR 存放数据

![](/static/images/blog/2025/408-co/Pasted%20image%2020250716164009.webp)

| MAR位数                          | MDR位数                     |
| -------------------------------- | --------------------------- |
| **地址码长度**，可算存储单元个数 | 存储**字**长                |
| 4位 = $2^4$个存储单元            | 16位 = 1个存储单元存放16bit |

注意：

- 字长是可变的，字节是不变的 = 8bit
- MDR规定存储**字**长，即规定了1个字=16bit

### 1.2.2 运算器

运算器由 ALU、移位器、状态寄存器（PSW）、通用寄存器组 组成。

![](/static/images/blog/2025/408-co/Pasted%20image%2020250716164724.webp)

- **ALU**：算数逻辑单元
  - 核心，其他三个只是寄存器
- ACC：累加寄存器
- MQ：乘商寄存器
- X：**通用**操作数寄存器

### 1.2.3 控制器

![](/static/images/blog/2025/408-co/Pasted%20image%2020250716165141.webp)

- CU：控制单元，核心，**给出控制信号**

### 1.2.4 硬件工作过程

- [1.2.2\_各个硬件的工作原理\_哔哩哔哩\_bilibili](https://www.bilibili.com/video/BV1ps4y1d73V?spm_id_from=333.788.videopod.sections&vd_source=7f5cf2ae748c813cc5d4d6f55495312c&p=5)

![](/static/images/blog/2025/408-co/Pasted%20image%2020250716165612.webp)

每一步过程都类似：

1. **取指令**：
   1. PC to MAR
   2. MDR to IR：取指令到IR
2. **分析指令**：
   1. IR.op to CU：指令的操作码送到 CU，CU分析指令
3. **执行指令**
   1. IR.ad to MAR：指令的地址码送到 MAR
   2. 后续操作看具体的指令

## 1.3 计算机软件

### 1.3.1 两类软件

- **系统软件** 管理计算机系统的硬件资源，向上层应用程序提供服务。
- **应用软件** 按应用场景需要编制成的各种程序，直接为用户提供服务。

### 1.3.2 三个级别的语言

1. 高级语言
2. 汇编语言：用**助记符**编写，以便记忆
   1. **一条汇编指令几乎总是对应一条机器指令**
      1. 真题中说指令一般是指机器指令，但是机器指令和汇编指令从本质上说都指向了同一个“指令”的抽象概念，不应该割裂理解。
      2. 汇编指令只是机器指令的便于人类记忆的形式罢了
3. 机器语言：计算机**唯一**可以直接执行的语言

- 汇编语言和机器语言都与计算机系统结构有关

三种程序：

- 编译程序/器：将高级语言一次全部翻译为汇编语言/**直接翻译为机器语言**。
- 汇编程序/器：将汇编语言翻译成机器语言。
- **解释**程序/器：高级语言翻译为机器语言（翻译一句执行一句）。

### 1.3.3 软件和硬件的逻辑功能等价性

同一个功能，既可以用硬件实现，也可以用软件实现。

### 1.3.4 指令集体系结构 (ISA)

- Instruction Set Architecture

一台计算机可以支持哪些指令，以及每条指令的作用是什么、每条指令的用法是什么。

### 1.3.5 计算机系统的层次结构

**计算机系统包含：软件 + 硬件**
![](/static/images/blog/2025/408-co/Pasted%20image%2020250718141347.webp)

### 1.3.6 工作原理

从 源程序 到 可执行文件 的流程：

1. **编程**：程序员编写 C 语言源程序（如 `hello.c` ）。
2. **预处理**：
   - 工具：预处理器
   - 输入输出：`hello.c` → `hello.i`
   - 为什么是 `.i`：因为预处理器最核心的功能之一就是处理 `#include` 指令，将所有依赖的头文件内容整合到一个文件中
3. **编译**：
   - 工具：编译器
   - 输入输出：`hello.i` → `hello.s`（汇编语言程序 ）
4. **汇编**：
   - 工具：汇编器
   - 输入输出：`hello.s` → `hello.o`（机器语言程序，即目标模块 ）
5. **链接**：
   - 工具：链接器
   - 输入：`hello.o`、其他被引用目标模块（如 `print.o` ）
   - 输出：`hello.exe`（可执行文件）
   - 将多个相关目标模块链接成完整可执行文件

![](/static/images/blog/2025/408-co/Pasted%20image%2020250718141711.webp)

## 1.4 性能指标

### 1.4.1 存储器性能指标

![](/static/images/blog/2025/408-co/Pasted%20image%2020250718142029.webp)

#### 字长概念辨析

1. **机器字长**：
   1. 简称字长
   2. 是 CPU 内部用于**整数运算**的**数据通路**的宽度
   3. 表示 CPU 一次可以处理的最大二进制位数
   4. `机器字长 = CPU 内部的通用寄存器位数`
   5. `机器字长 = CPU 内部的运算器位数`
2. 存储字长：一个存储单元中的二进制位数
3. 指令字长：一个指令字包含的二进制位数

它们必须都是 1 字节的整数倍。

### 1.4.2 CPU性能指标

1. CPU时钟周期
2. CPU主频：

   $$
   \text{CPU主频（时钟频率）} = \frac{1}{\text{CPU时钟周期}}
   $$

3. CPI （Clock cycle Per Instruction）：执行一条指令所需的时钟周期数。

![](/static/images/blog/2025/408-co/Pasted%20image%2020250718142619.webp)

4. IPS：每秒执行多少条指令1. MIPS：每秒执行多少百万条指令

   $$
   IPS = \frac{\text{主频}}{\text{平均}CPI}
   $$

5. FLOPS：每秒执行多少次浮点运算
   - KFLOPS（Kilo）：千，对应 $10^3$
   - MFLOPS（Million）：百万，对应 $10^6$
   - GFLOPS（Giga）：十亿，对应 $10^9$
   - TFLOPS（Tera）：万亿，对应 $10^{12}$
   - PFLOPS（Peta）：千万亿，对应 $10^{15}$，考过这种题，😅
   - EFLOPS（Exa）：百京，对应 $10^{18}$

![](/static/images/blog/2025/408-co/Pasted%20image%2020250718143646.webp)

### 1.4.3 系统整体性能指标

1. 数据通路带宽：数据总线一次所能并行传送的位数
2. 吞吐量：系统在单位时间处理的请求数
3. 响应时间：发送请求到做出响应的时间

动态测试：可以用**基准程序**来测量计算机处理速度

#### 辨析

![](/static/images/blog/2025/408-co/Pasted%20image%2020250718151711.webp)

---

# 2 数据的表示和运算

## 2.1 数制与编码

常识：

$$
2^{16} = 65536
$$

$$
2^{15} = 32768
$$

$$
FFFFH = 1 \dots 1 = 65535
$$

### 2.1.1 进位计数制

**基数**：每个数码位所用到的不同符号的个数

- r进制的基数为r

![](/static/images/blog/2025/408-co/Pasted%20image%2020250718152638.webp)

### 2.1.2 进制转换

#### 2.1.2.1 转十进制

按位权

![](/static/images/blog/2025/408-co/Pasted%20image%2020250718152759.webp)

#### 二八六转换

符号对应

![](/static/images/blog/2025/408-co/Pasted%20image%2020250718152830.webp)

#### 十进制转换

整数部分：短除法
![](/static/images/blog/2025/408-co/Pasted%20image%2020250718153115.webp)

小数部分：乘r取整
![](/static/images/blog/2025/408-co/Pasted%20image%2020250718153317.webp)

拼凑法：
![](/static/images/blog/2025/408-co/Pasted%20image%2020250718153539.webp)

### 2.1.3 真值 机器数

| 真值         | 机器数                 |
| ------------ | ---------------------- |
| +15          | 01111                  |
| 符合人类习惯 | 数字实际存到机器的形式 |

注意，机器数的正负需要被数字化，多加一位0/1表示符号。

- **408中机器数到底是原码还是补码请看题干**

### 2.1.4 定点数

定点数：

- 无符号数：n位无符号数字的范围是 $[0, 2^n-1]$
- 有符号数
  - 原码
  - 反码
  - 补码
  - 移码

#### 有符号数的定点表示

![](/static/images/blog/2025/408-co/Pasted%20image%2020250718154904.webp)

#### 原码

![](/static/images/blog/2025/408-co/Pasted%20image%2020250718155125.webp)

#### 反码

正数的反码 = 原码
负数的反码 = 数值位取反

![](/static/images/blog/2025/408-co/Pasted%20image%2020250718155603.webp)

#### 补码

- C语言数据在内存中，以**补码**形式存放

正数的补码 = 原码
负数的补码 = 反码末位+1，**需要进位**

- 补码 to 原码也是同样的操作

1. 补码和移码的 0 只有一种表示形式；而原码和反码有两种 1. 故，补码和移码范围 + 1 2. 补码可以额外表示的数字：1. 注意，10000000没有原码对应的真值，因为原码无法表示 $2^{-7}$
   ![](/static/images/blog/2025/408-co/Pasted%20image%2020250718155938.webp)
2. 补码可以把减法转为加法：
   ![](/static/images/blog/2025/408-co/Pasted%20image%2020250718163325.webp)

补充：

- 由$[x]_{补}$补快速求$[-x_{补}]$的方法：**符号位**、数值位**全部取反**，末位+1

#### 移码

移码 = 补码的**符号位取反**

- 移码只能表示整数
- 移码的真值0也只有一种形式
- 表示范围和补码相同

移码可以用于比较大小，从最高位开始，先出现1的数大。

- 移码是单调增，补码是**分两个周期**线性增大（-128~-1 和 0~127）
  ![](/static/images/blog/2025/408-co/Pasted%20image%2020250718160338.webp)

或者加偏置值

### 2.1.5 语言强制转换

short to int：

- 有符号数：**符号扩展**，且不改变真值
- 无符号数：零扩展
  int to short：高位截断

![](/static/images/blog/2025/408-co/Pasted%20image%2020250718170014.webp)

#### 零扩展 符号扩展

- 零扩展适用于无符号数，用0扩展高位
- 符号扩展适用与有符号数，用符号位扩展高位

### 2.1.6 逻辑门电路基础

#### 2.1.6.1 逻辑门

![](/static/images/blog/2025/408-co/Pasted%20image%2020250718170616.webp)

补充：n个bit进行异或

- 若有奇数个1则异或结果为1
- 若有偶数个1则异或结果 0

#### 公式

![](/static/images/blog/2025/408-co/Pasted%20image%2020250718171654.webp)

#### 多路选择器

![](/static/images/blog/2025/408-co/Pasted%20image%2020250718171841.webp)

#### 三态门

![](/static/images/blog/2025/408-co/Pasted%20image%2020250718171943.webp)

三态：高电平、低电平、高阻态

- 高阻态 = 断线

## 2.2 运算方法和运算电路

### 2.2.1 加法器

#### 串行进位加法器

- 串行进位又称为行波进位
- 但是属于并行加法器，见术语辨析

![](/static/images/blog/2025/408-co/Pasted%20image%2020250804170758.webp)

问题：进位信息串行传递，导致计算速度取决于进位产生和传递速度

#### 术语辨析

1. 由于两个输入端允许**并行**输入 n bit，因此这种加法器属于：**并行加法器**
2. 由于进位信息是**串行**产生的，因此从“进位方式”看，这种加法器属于：**串行进位加法器**
3. 综上，很多教材把这种加法器称为：**串行进位**的**并行**加法器

#### 并行进位加法器

加入了CLA部件，使得所有进位信息同时产生。

![](/static/images/blog/2025/408-co/Pasted%20image%2020250804171301.webp)

#### 带标志位的加法器

![](/static/images/blog/2025/408-co/Pasted%20image%2020250804171728.webp)

- OF（Overflow Flag）溢出标志，用于判断**带符号数**加减运算是否溢出。
  - OF=1 溢出：OF=0 未溢出
  - 也用于表示**有符号/无符号整数乘法**是否溢出
- SF（Sign Flag）符号标志，用于判断**有符号数**加减运算结果的**正负性**。
  - SF=1 结果负：SF=0 结果为正
- ZF（Zero Flag）零标志，用于判断加减运算结果是否为0。
  - ZF=1 表示结果0；ZF=0 表示结果不为0
- CF（Carry Flag）进位/借位标志，用于判断**无符号数**加减运算是否溢出。
  - CF=1 溢出：CF=0 未溢出

**注意，SF 和 OF 对于无符号数运算没有意义！**

- 408p172.27.2011真题

### 2.2.2 算数逻辑单元 ALU

![](/static/images/blog/2025/408-co/Pasted%20image%2020250804174620.webp)

CPU

- 控制器
- 运算器
  - ALU
    - 加法器
  - 通用寄存器
  - 状态寄存器 PSW
  - 移位器

ALU是运算器的核心；加法器是ALU的核心。

#### 功能

**重点：如果ALU支持 $k$ 种功能，则控制信号位数 $m \geq \lceil \log_{2}k \rceil$**
![](/static/images/blog/2025/408-co/Pasted%20image%2020250804174925.webp)

$$
\text{ALU 运算位数 }n = \text{机器字长}
$$

$$
\text{PSW 程序状态字寄存器} = \text{FR 标志寄存器}
$$

![](/static/images/blog/2025/408-co/Pasted%20image%2020250804175320.webp)

### 2.2.3 定点数的移位

左右移动 $r$ 位 约等于 乘除 $2^r$

#### 逻辑移位

用于无符号整数

左移：高位丢弃，低位补零

- 右移类似，但是右移丢弃位 = 1则会**损失精度**
- 溢出判断：丢弃位是否为 1

![](/static/images/blog/2025/408-co/Pasted%20image%2020250804181253.webp)

#### 算数移位

用于有符号整数

左移：移动与逻辑移位完全相同，**符号位一起移动**

- 溢出判断不同，改为**判断符号位是否改变**
  ![](/static/images/blog/2025/408-co/Pasted%20image%2020250807163637.webp)

右移高位补充**符号位**，丢弃位 = 1则也会损失精度
![](/static/images/blog/2025/408-co/Pasted%20image%2020250807164006.webp)

### 2.2.4 定点数的加减

原码运算麻烦，一般采用补码运算

#### 原码加减

绝对值加减，再处理符号
![](/static/images/blog/2025/408-co/Pasted%20image%2020250807170117.webp)

#### 补码加减

1. 减法 = 加负数
2. **符号位直接参与运算**

![](/static/images/blog/2025/408-co/Pasted%20image%2020250807170609.webp)

溢出判断：
![](/static/images/blog/2025/408-co/Pasted%20image%2020250807172240.webp)

由上图易知，溢出情况**看符号位即可**：

1. 上溢：正 + 正 = 负 0 0 1
2. 下溢：负 + 负 = 正 1 1 0

- 这个就是判断后文 OF 溢出标志位的方法
- 减法看成加负的数即可，也可以按照 001 和 110 推导

#### 模4 和 模2 补码

模4：双符号位
模2：单符号位
![](/static/images/blog/2025/408-co/Pasted%20image%2020250807173135.webp)

### 2.2.5 无符号数的加减

加法：按位相加即可
![](/static/images/blog/2025/408-co/Pasted%20image%2020250807173356.webp)

减法：减数取补码，减法变加法
![](/static/images/blog/2025/408-co/Pasted%20image%2020250807174111.webp)

#### 溢出判断

![](/static/images/blog/2025/408-co/Pasted%20image%2020250807174243.webp)

- 考试时，直接按照十进制算一下即可
- 注意，**无符号数是没有负数的**，$127-128 = -1$ 是溢出的！

结合标志位理解：
![](/static/images/blog/2025/408-co/Pasted%20image%2020250807180425.webp)

### 2.2.6 补码加减运算电路

补码加减运算电路实现了无符号数和有符号数的统一，电路只是计算两个二进制串，并不关心是否有符号。

- 对于 OF 标志位，当作**有符号数**理解，判断加/减是否有溢出即可
- 对于 CF 标志位，当作**无符号数**理解，判断加/减是否有进位/借位即可 - 可能涉及有符号数到无符号数的转换，快速方法是 $-x = 2^k-x$
  ![](/static/images/blog/2025/408-co/Pasted%20image%2020250811195515.webp)

当然也可以按公式算，不过就**慢**了。
![](/static/images/blog/2025/408-co/Pasted%20image%2020250811192622.webp)

- 大题写计算过程可能需要公式

sub 信号的两点作用：

1. 多路选择器由 sub 信号控制，实现了（减法时）减数取反的操作
2. sub 信号作为 cin （来自低位的进位），实现了取反之后 + 1

![](/static/images/blog/2025/408-co/Pasted%20image%2020250807175359.webp)

注意，加法器的（加数）输入端仅取反，加1操作依靠 cin 的进位（sub信号）

### 2.2.7 无符号整数的乘法

- 王道说明：考纲侧重考察在**整数**的乘除法，而教材以浮点数的乘除法作为引入

![](/static/images/blog/2025/408-co/Pasted%20image%2020250807183851.webp)

#### 电路

特殊处理：控制逻辑会先检查两个是否都是 0，如果是则直接结果为 0

循环：
![](/static/images/blog/2025/408-co/Pasted%20image%2020250807203616.webp)

关于乘法溢出判断：

- 实际上，P Y寄存器共 2n 位，而两个 n 位整数乘法结果一定小于 2n，计算过程中是不可能溢出的
- 但是，由于计算机只保留 n 位，所以**结果上可能溢出**
  ![](/static/images/blog/2025/408-co/Pasted%20image%2020250807203652.webp)

溢出实例 及 2 种溢出处理：
![](/static/images/blog/2025/408-co/Pasted%20image%2020250807203947.webp)

注意：

- 有/无符号整数乘法都是用 OF 标志位记录溢出
- 无符号整数乘法时，CF 也会记录

### 2.2.8 有符号整数的乘法

- 简单思路是直接算绝对值，符号位异或
- 王道网课用了纯电路的方式实现
- 这个方法叫**补码一位**乘法，Booth乘法

电路的主要区别是：

1. 在最右侧添加了辅助位，初始为 0
2. ALU 可以执行加减法
3. 改为**算数右移**

另外添加了一个比较繁琐的规则，见左表：
![](/static/images/blog/2025/408-co/Pasted%20image%2020250807205441.webp)

溢出判断：

- 检查高 $n+1$ 位是否完全相同
- 不完全相同则溢出

![](/static/images/blog/2025/408-co/Pasted%20image%2020250807205939.webp)

注意，有/无符号整数乘法都是用 OF 标志位记录溢出。

### 2.2.9 计算机实现乘法电路的三种方式

上一节的电路实现 n bit 无符号数相乘，至少需要 n 个**时钟**。

#### 两位乘法

改进方案：可以实现“两位乘法”，每轮处理乘数寄存器Y的末尾2bit，实现，此时仅需 **n/2 个时钟**即可完成运算

- 具体如何实现两位乘法没有深入

![](/static/images/blog/2025/408-co/Pasted%20image%2020250808004224.webp)

#### 阵列乘法器

- **快速**乘法器

可以在 **1 个时钟**内完成乘法运算
![](/static/images/blog/2025/408-co/Pasted%20image%2020250808004055.webp)

#### 逻辑运算等效

运算速度很慢
![](/static/images/blog/2025/408-co/Pasted%20image%2020250808004557.webp)

#### 总结

- 速度：阵列 > ALU移位 > 逻辑等效
- 本节的三种方法，对于有无符号整数都适用

### 2.2.10 无符号整数的除法运算

- **除法异常**包括：商溢出、除数0

#### 手算

二进制和十进制差不多，很简单

![](/static/images/blog/2025/408-co/Pasted%20image%2020250808011209.webp)

#### 除法电路

被除数作零拓展
![](/static/images/blog/2025/408-co/Pasted%20image%2020250809192635.webp)

特殊情况：

1. 除数 = 0，**异常**停止
2. 被除数 < 除数，商 = 0

具体过程：
![](/static/images/blog/2025/408-co/Pasted%20image%2020250809194208.webp)

- 判断商溢出：看第一位商（**第一轮**特殊处理）
  - 1，则**商溢出异常**，停止
    - 由于默认高4位填充 0，
    - 所以 n 除 n 时（单精度）不可能商溢出，
    - 2n 除 n 时（双精度）可能溢出，
    - 这一点商溢出小节有提到。
  - 0，则这次计算不可能发生溢出
- 有关ALU**加法操作**：
  - 上商 0 的时候，ALU实际上还是做了 $R - Y$ 的操作（发现小于 0 才判断上商 0），所以需要**做一次 $+ Y$ 的操作**，使得余数恢复为正确的值，之后再左移。
  - 所以，ALU实际上的过程和手算的中间余数不一样，手算是人脑判断之后直接 $- 0000$
  - 称作**恢复余数法**

#### 商溢出

![](/static/images/blog/2025/408-co/Pasted%20image%2020250809223204.webp)

按被除数 n/2n 分为单双精度

- 双精度可能溢出
- 单精度**不可能**溢出

## 2.3 浮点数

### 2.3.1 IEEE 754

- 二进制浮点数算数标准

C语言的 float（**单精度 32bit**）、double（**双精度 64bit**）就是符合 IEEE 754 标准的浮点数格式。

二进制科学计数法

- 引入 符号、尾数、基数、阶码的概念
  ![](/static/images/blog/2025/408-co/Pasted%20image%2020250809225956.webp)

浮点数由 符号、阶码、尾数 组成

- 尾数的位数决定了精度
- 阶码的位数决定了表示范围
  ![](/static/images/blog/2025/408-co/Pasted%20image%2020250809230327.webp)

#### float 的存储

![](/static/images/blog/2025/408-co/Pasted%20image%2020250809231248.webp)

1. 尾数省略了小数点前的 1（但是尾数概念本身包含这个 1），省略是因为这是隐含的，不用浪费空间表示；所以，实际上 23 bit 表示的是 24 bit 的精度。
2. 如何求移码：十进制 + 偏置值，转为二进制

#### double 的存储

基本一致，注意记忆偏置值
![](/static/images/blog/2025/408-co/Pasted%20image%2020250809231924.webp)

#### 例题

![](/static/images/blog/2025/408-co/Pasted%20image%2020250809232411.webp)

### 2.3.2 浮点数表示范围

![](/static/images/blog/2025/408-co/Pasted%20image%2020250810003754.webp)

#### 特殊状态的浮点数

- 阶码全 0 / 1，视为特殊状态

![](/static/images/blog/2025/408-co/Pasted%20image%2020250809234003.webp)

#### 规格化浮点数

- 注意，规格化的阶码不存在全 0 / 1

float 阶码真值表示范围：
![](/static/images/blog/2025/408-co/Pasted%20image%2020250809233922.webp)

float 规格化浮点数表示范围：
![](/static/images/blog/2025/408-co/Pasted%20image%2020250809234504.webp)

- 理解 $2 - 2^{-23}$：$2^{-23}$ 是尾数第23位
- 正负是对称的，注意，表示范围不包括 0

其实从这个图也可以理解：

- 阶码全 1 （127+1）表示无穷大
- 阶码全 0 （-126-1）表示零
- 注意，127、-126是**移码**
  - 移码转换：
    - 127 是 127+127=254；
    - 127+1 是 128+127=255；
    - 255 是 全 1

#### 下溢处理

![](/static/images/blog/2025/408-co/Pasted%20image%2020250810000839.webp)

#### 非规格化浮点数

临界值要记住，最大最小的数
![](/static/images/blog/2025/408-co/Pasted%20image%2020250810001326.webp)

1. 非规格化表示的阶码固定为 -126
2. 尾数不能为全零
3. 尾数解读为 **0.xxxx** 而不是正常的 1.xxxx

负数同理：
![](/static/images/blog/2025/408-co/Pasted%20image%2020250810001909.webp)

### 2.3.3 浮点数加减运算

浮点数运算的特点：阶码运算和尾数运算分开。

#### 对阶

对阶：使两个操作数的小数点对齐，使得两个数的**阶码相同**。

- 一般是 小阶向大阶对齐

对阶会导致尾数右移，为保证精度，应该不丢弃移出的尾数，使其参与尾数运算。

#### 规格化

规格化：将尾数改写为 $\pm 1.x x x$ 形式。

1. 右规：尾数右移（小数点左移），阶码 + 1
2. 左规：尾数左移（小数点右移），阶码 - 1

#### 舍入

对阶和右规时移出的位会保留，在舍入这一步时做具体的舍去操作。

1. 就近舍入
2. 正/负向舍入
3. 截断法

#### 溢出判断

1. 左右规：可能指数下/上溢
2. 尾数舍入：可能尾数溢出，溢出需要通过右规调整，然后又可能指数上溢。

尾数溢出，结果**不一定**溢出。

- 尾数溢出可以通过右规调整，所以不一定溢出
- 当然调整之后可能指数溢出，最终导致溢出
- 结果是否溢出主要看指数溢出

### 2.3.4 数据存储和排列

大端：高字节在低地址
小端：高字节在高地址

- 注意，以字节（2位16进制）为单位
  ![](/static/images/blog/2025/408-co/Pasted%20image%2020250810004536.webp)

边界对齐

- 一般是按字节编址，即一个地址对应一个字节
  ![](/static/images/blog/2025/408-co/Pasted%20image%2020250810004840.webp)

## 2.4 补充：C语言

在 C 语言里，类型的长度（字节数）取决于编译器实现和平台架构，但常见的 32 位、64 位主流平台（如 Windows x86/x64、Linux x86_64、macOS ARM64）大致遵循下面的规律：

| 类型        | 常见字节数（bytes） | 常见位数（bits） | 备注                                                    |
| ----------- | ------------------- | ---------------- | ------------------------------------------------------- |
| `char`      | 1                   | 8                | **保证**是 1 字节（标准规定 `sizeof(char)` 永远是 1）。 |
| `short`     | 2                   | 16               | 最少 16 位（标准只保证 ≥16 位）。                       |
| `int`       | 4                   | 32               | 在现代主流桌面平台几乎都是 32 位。                      |
| `long`      | 4 / 8               | 32 或 64         | Win 平台的 LLP64 模型 vs Unix/Linux 的 LP64 模型。      |
| `long long` | 8                   | 64               | 标准保证 ≥64 位，几乎总是 64 位。                       |
| `float`     | 4                   | 32               | IEEE 754 单精度。                                       |
| `double`    | 8                   | 64               | IEEE 754 双精度。                                       |

# 3 存储系统

## 3.1 存储器概述

![](/static/images/blog/2025/408-co/Pasted%20image%2020250812165932.webp)

- 辅存中的数据需要调入主存后才能被 CPU 访问

主存与辅存：实现了**虚拟存储系统**，解决了主存容量不够的问题

Cache与主存：解决了主存与 CPU 速度不匹配的问题（CPU 速度更快）

### 3.1.1 存取方式

![](/static/images/blog/2025/408-co/Pasted%20image%2020250812170635.webp)

1. 随机存取存储器 RAM：支持随机访问
2. 顺序存取存储器 SAM：只能顺序访问
3. 直接存取存储器 DAM：支持直接选取区域（随机访问），区域内按顺序访问
   1. 磁盘是 DAM
4. 相联存储器 CAM：按照内容检索 或者 地址检索
   1. **快表**是一种相联存储器

### 3.1.2 性能指标

![](/static/images/blog/2025/408-co/Pasted%20image%2020250812171203.webp)

1. 存储容量 $$\text{存储字数} \times \text{字长}$$

2. 单位成本 $$\frac{\text{总成本}}{\text{总容量}}$$

3. 存储速度 $$\text{数据传输率} = \frac{\text{数据宽度}}{\text{存储周期}}$$

4. $存储周期 = 存取时间 + 恢复时间$

5. 数据传输率也称**主存带宽**

## 3.2 主存储器

主存储器是内存，主要有 RAM 和 ROM 两种。

- RAM：易失性，断电后数据丢失
- ROM：非易失性

### 3.2.1 半导体原理

![](/static/images/blog/2025/408-co/Pasted%20image%2020250812195822.webp)

存储字：一次可以读出的 bit 数

存储字长：

- 存储字的长度
- 一个存储单元中的二进制位数
- 一个存储单元中的**存储元**数量

多个存储单元构成存储体/存储矩阵。

### 3.2.2 存储器芯片原理

1. CPU 通过 地址总线 传递地址 to MAR
2. 控制电路 控制 MAR
3. MAR to 译码器
4. 译码器 选择 存储元
5. 存储元 to MDR

![](/static/images/blog/2025/408-co/Pasted%20image%2020250812200912.webp)

- 读写线可能有 1 或者 2 根
- 片选线：选择哪个芯片
  ![](/static/images/blog/2025/408-co/Pasted%20image%2020250812201927.webp)

引脚数量：

- 每个线对应一个引脚
- 读写线可能有 2 根
  ![](/static/images/blog/2025/408-co/Pasted%20image%2020250812202046.webp)

### 3.2.3 寻址

![](/static/images/blog/2025/408-co/Pasted%20image%2020250812202319.webp)

### 3.2.4 DRAM 与 SRAM

RAM 主要有 DRAM、SRAM：

- Static and Dynamic
- 上一节的是 DRAM

DRAM芯片：使用**栅极电容**存储信息，常用作主存
SRAM芯片：使用**双稳态触发器**存储信息，常用作 Cache

- 核心区别：存储元不一样

| 类型特点                 | DRAM（动态RAM）        | SRAM（静态RAM）        |
| ------------------------ | ---------------------- | ---------------------- |
| 存储信息                 | 电容                   | 触发器                 |
| **破坏性**读出           | 是                     | 非                     |
| 读出后需要重写？（再生） | 需要                   | 不用                   |
| 运行速度                 | 慢                     | **快**                 |
| 集成度                   | **高**                 | 低                     |
| 发热量                   | **小**                 | 大                     |
| 存储成本                 | **低**                 | 高                     |
| 易失/非易失性存储器？    | 易失（断电后信息消失） | 易失（断电后信息消失） |
| 需要**刷新**             | 需要                   | 不需要                 |
| 送行列地址               | **分两次送**           | 同时送                 |

- DRAM 分两次送地址是由于地址线复用，使**地址线、地址引脚减半**

#### DRAM 芯片的行列计算

- **重要补充，网课这块不扎实**

假定有一个 $2^n \times b$ 位的 DRAM 芯片，它实际上是一个**存储阵列**

- 芯片中每个存储单元包含 $b$ 位
- 行数 $r$ 和列数 $c$ 满足 $r\times c = 2^n$
  - 由于按行刷新，所以满足 $r \leq c$
  - 尽量使行列数相同
  - 或者有些题会直接给出 $row \times column \times b$ 位的形式

#### DRAM 刷新

为什么 DRAM 需要刷新？
![](/static/images/blog/2025/408-co/Pasted%20image%2020250814184341.webp)

如何刷新：
![](/static/images/blog/2025/408-co/Pasted%20image%2020250814201709.webp)

三种刷新方式：

1. 分散刷新：刷新太频繁
2. 集中刷新：有死区
3. 异步刷新：死区小
   ![](/static/images/blog/2025/408-co/Pasted%20image%2020250814202232.webp)

刷新由存储器独立完成，无需 CPU 介入。

现在的主存已经抛弃了 DRAM，主要使用 SDRAM，例如 ddr4。

#### SDRAM

- SDRAM（Synchronous DRAM）

SDRAM 的工作方式与传统的 DRAM 有很大不同。

- 传统 DRAM 与CPU 之间采用**异步**方式交换数据，CPU 发出地址和控制信号后，经过一段延迟时间，数据才读出或写入。
  - 在这段时间里，CPU 不断采样 DRAM 的完成信号，在没有完成之前，CPU 插入等待状态而不能做其他工作。
- SDRAM 采用**同步**方式

#### 行缓冲寄存器

![](/static/images/blog/2025/408-co/Pasted%20image%2020250815203521.webp)

例如，要从图 6-3中 $16×8$ 的DRAM中读出超单元（2,1），内存控制器发送行地址2，如下图a所示。

**DRAM 的响应是将行 2 的整个内容都复制到一个内部行缓冲区**。接下来，内存控制器发送列地址1，如下图b所示。DRAM的响应是从行缓冲区复制出超单元（2,1）中的8位，并把它们发送到内存控制器。

![](https://pic2.zhimg.com/v2-bb76be90414fd48d198491ba55acab49_1440w.jpg)

超单元：多位就是超单元
![](/static/images/blog/2025/408-co/Pasted%20image%2020250815232121.webp)

### 3.2.5 ROM

各种 ROM：

- MROM（**Mask** Read Only Memory）：
  - 厂家按客户需求在芯片生产时写入信息，**不可重写**，可靠性高、灵活性差、生产周期长，适合批量定制。
- PROM（**Programmable** Read Only Memory）：
  - 用户可用专门写入器写入信息，**写一次后不可更改**。
- EPROM（**Erasable** Programmable Read Only Memory）：
  - 允许用户写入信息，之后可擦除数据并**多次重写**；
  - 支持随机存取
  - UVEPROM：用紫外线照射8 - 20分钟擦除**所有**信息
  - EEPROM（也记为E^2PROM）可用“电擦除”方式擦除**特定**的字。
- Flash Memory（闪速存储器、闪存）：
  - **U盘、SD卡属于闪存**，由EEPROM发展而来，断电能保存信息且可多次快速擦除重写
  - 每个存储元只需单个MOS管，位密度比RAM高，闪存**写速度比读速度慢**；
  - 手机辅存使用Flash芯片，不过相比SSD使用的芯片，集成度低、功耗高、价格便宜。
- SSD（Solid State Drives）：
  - 由控制单元 + 存储单元（Flash芯片）构成，与闪存核心区别在控制单元，存储介质类似，可多次快速擦除重写，速度快、功耗低、价格高，
  - 常用于个人电脑手机

计算机内的 RAM 和 ROM：
![](/static/images/blog/2025/408-co/Pasted%20image%2020250814203857.webp)

- 操作系统在辅存（ROM）
- BIOS 属于 ROM
- RAM 和 ROM 一般统一编址，如图所示

### 3.2.6 双端口 RAM

![](/static/images/blog/2025/408-co/Pasted%20image%2020250814204336.webp)

![](/static/images/blog/2025/408-co/Pasted%20image%2020250814204557.webp)

- 作用：优化**多核**CPU访问**一根**内存条的速度。
- 硬件要求：需要有两组完全独立的数据线、地址线、控制线，CPU、RAM中也要有更复杂的控制电路。

两个端口对同一主存操作的4种情况：

1. 两个端口同时对不同的地址单元存取数据。
2. 两个端口同时对同一地址单元读出数据。
3. 两个端口同时对同一地址单元写入数据，会出现**写入错误**。
4. 两个端口同时对同一地址单元，一个写入数据，另一个读出数据，会出现**读出错误**。

### 3.2.7 多模块存储器

多模块存储器主要有：多体并行存储器 和 单体多字存储器。

重要概念：

- **多模块交叉编址**
  - 多模块交叉编址是将一个大的存储空间分成多个小的存储模块，并将这些模块按照一定的规则进行编址，使得在访问连续的存储单元时，可以访问到不同的模块，从而实现**并行访问**。
- **轮流启动**
  - 在轮流启动方式下，系统会按照一定的时间间隔（一个存储器周期）依次启动各个存储模块，进行读写操作。这种方式适用于每个存储模块一次读写的位数（一个存储字）正好等于系统总线数据线位数的情况。
- **同时启动**
  - 在同时启动方式下，所有存储模块会同时启动，进行读写操作。这种方式适用于**所有存储模块一次并行读写的总位数正好等于系统总线数据线位数**的情况。
    - 2022真题：存储器总线宽度 恰好等于 所有模块的总位数，可以判断采用了多模块交叉编址 且 采用了同时启动的方式。

#### 多体并行存储器

高位 / 低位交叉编址：
![](/static/images/blog/2025/408-co/Pasted%20image%2020250814205132.webp)

- 存取周期 $T = 4r$ 分为 $存取时间 r + 等待时间(恢复)3r$

**高位交叉**由于连续访问的地址都在**同一条**内存，所以每次存取完都需要等待 $3r$

- **理论上多个存储体可以被并行访问**，但是由于通常会连续访问，因此高位交叉实际效果相当于单纯的扩容，所以一般不用高位

**低位交叉**的等待和存取在不同内存条，所以不冲突，可以实现**并行访问**

流水线方式：
![](/static/images/blog/2025/408-co/Pasted%20image%2020250814205833.webp)

- 注意，存取时间 = 总线传输周期

注意，题目中提到交叉编址，一般是指**低位交叉**，因为高位交叉又称连续编址。

#### 单体多字存储器

1. 每个存储单元存储 m 个字
2. 总线宽度也是 m 个字
3. 只能一次并行读取 m 个字，灵活性差
4. 指令和数据在主存必须连续存放
   ![](/static/images/blog/2025/408-co/Pasted%20image%2020250814210222.webp)

## 3.3 主存储器与CPU的连接

存储器的输入输出信号：
![](/static/images/blog/2025/408-co/Pasted%20image%2020250814214327.webp)

### 3.3.1 位扩展

两块存储芯片：
![](/static/images/blog/2025/408-co/Pasted%20image%2020250814214421.webp)

扩展到 n 块：
![](/static/images/blog/2025/408-co/Pasted%20image%2020250814214245.webp)

### 3.3.2 字扩展

![](/static/images/blog/2025/408-co/Pasted%20image%2020250814214640.webp)

- 用 A13、14 两位作为片选信号，选择读取指定的芯片

使用1-2 译码器改进：
![](/static/images/blog/2025/408-co/Pasted%20image%2020250814214953.webp)

- 原来需要占用 2 位作为片选信号，现在只需要 **1 位**（A13）
  - 在地址中只占用 1 位（最高位）
- **译码片选法**的核心就是 $n \text{ to } 2^n$
- 注意：
  - 图中 1-2 译码器的输入有一个非门，为了避免产生相同信号（导致同时读）
  - 图中可以看到地址除最高位外，还有 13 位，对应 A0 ~ A12 这 13 位地址

3-8 译码器：
![](/static/images/blog/2025/408-co/Pasted%20image%2020250814215933.webp)

|            | 线选法             | 译码片选法             |
| ---------- | ------------------ | ---------------------- |
| 选片信号   | n 条线 n个选片信号 | n条线 $2^n$ 个选片信号 |
| 电路复杂度 | 电路简单           | 电路复杂               |
| 地址空间   | 地址空间不连续     | **地址空间连续**       |

### 3.3.3 字位同时扩展

2个四位存储器芯片叠一起 作为 位扩展，四组叠叠乐 形成 字扩展。
![](/static/images/blog/2025/408-co/Pasted%20image%2020250814220208.webp)

地址如下：
![](/static/images/blog/2025/408-co/Pasted%20image%2020250815001255.webp)

## 3.4 外部存储器

![](/static/images/blog/2025/408-co/Pasted%20image%2020250815002219.webp)

### 3.4.1 磁盘的组成

磁头、柱面、扇区：
![](/static/images/blog/2025/408-co/Pasted%20image%2020250815002602.webp)

### 3.4.2 磁盘的性能指标

#### 3.4.2.1 磁盘的容量

1. 一个磁盘所能存储的字节总数称为磁盘容量。磁盘容量有非格式化容量和格式化容量之分。
   1. 非格式化容量是指磁记录表面可以利用的磁化单元总数。
   2. 格式化容量是指按照某种特定的记录格式所能存储信息的总量。

#### 记录密度

记录密度是指盘片单位面积上记录的二进制的信息量，通常以道密度、位密度和面密度表示。

1. **道密度**是沿磁盘半径方向单位长度上的磁道数；
2. **位密度**是磁道单位长度上能记录的二进制代码位数；
   1. 越内侧的磁道，位密度越大
3. **面密度**是 位密度 和 道密度 的乘积。
   1. 注意：磁盘所有磁道记录的信息量一定是相等的，并不是圆越大信息越多，故每个磁道的位密度都不同。

![](/static/images/blog/2025/408-co/Pasted%20image%2020250815162826.webp)

#### 平均存取时间

![](/static/images/blog/2025/408-co/Pasted%20image%2020250815163042.webp)

注意：

1. $$\text{平均旋转延迟} = \frac{1}{2} \times \text{转一圈的时间}$$
2. 传输时间可以根据转速计算，约等于扫过一个扇区的时间，即 $$\text{转一圈的时间} / \text{一圈的扇区数}$$

#### 数据传输率

磁盘存储器在单位时间内向主机传送数据的字节数，称为数据传输率。

假设磁盘转数为 $r$（转/秒），每条磁道容量为 $N$ 个字节，则数据传输率为 $D_{r} = rN$

### 3.4.3 磁盘地址

![](/static/images/blog/2025/408-co/Pasted%20image%2020250815163742.webp)

### 3.4.4 磁盘工作过程

硬盘的主要操作是寻址、读盘、写盘。每个操作都对应一个控制字，硬盘工作时，第一步是取控制字，第二步是执行控制字。

硬盘属于机械式部件，其读写操作是**串行**的，**不可能在同一时刻既读又写**，也不可能在同一时刻读两组数据或写两组数据。

#### 改进：磁盘阵列

和低位交叉的思想类似，实现并行访问
![](/static/images/blog/2025/408-co/Pasted%20image%2020250815164113.webp)

- RAID0 把连续多个数据块交替地存放在不同物理磁盘的扇区中，几个磁盘交叉并行读写，不仅扩大了存储容量，而且提高了磁盘数据存取速度
  - 但 RAID0 **没有容错能力**。
- RAID1 是为了提高可靠性，使两个磁盘同时进行读写，互为备份，提供了**容错**。
  - 但是两个磁盘完全一致，意味着总容量减少一半，成本大。
- 之后 RAID 通过数据校验，保证安全性，且级数越大，冗余信息越少，成本越低。

### 3.4.5 固态硬盘

SSD 基于**闪存**技术（Flash Memory），属于电可擦除ROM（即EEPROM）。

组成：

1. 有闪存翻译层（负责翻译逻辑块号，找到对应页）
2. 存储介质为多个闪存芯片
   1. 每个芯片含多个块，每个块含多个页。

![](/static/images/blog/2025/408-co/Pasted%20image%2020250815171648.webp)

SSD 的读写是以**页**为单位的，而磁盘是以 扇区为单位。

- SSD 的若干页组成的一个块，相当于磁盘中的一个磁道

读写性能特性：

- 以**页**为单位读/写（相当于磁盘“扇区”）；
- 以**块**为单位**擦除**，擦干净的块中每页可写一次、**读无限次**；
- 支持随机访问，能通过电路由逻辑地址迅速定位物理地址；
- 读快、**写慢**
  - 如果写的页若有数据，由于写入需要擦除一整块的数据，所以需将块内其他页复制到新擦除块后，再写入新页
  - 同时，闪存翻译层会把地址映射到新的块

与机械硬盘相比的特点：

- 读写速度快、随机访问性能高，靠电路控制访问位置
  - 机械硬盘靠移动磁臂和旋转磁盘，有寻道时间和旋转延迟
- 安静无噪音、耐摔抗震、能耗低但造价更贵
- SSD的“块”擦除次数过多可能损坏，机械硬盘扇区不会因写次数多损坏。

**磨损均衡**技术：

- 思想是将“擦除”平均分布在各块以**提升使用寿命**
- **动态**磨损均衡是写入数据时**优先选累计擦除次数少**的新闪存块
- **静态**磨损均衡是SSD监测并自动进行数据分配、迁移，让**老闪存块承担以读为主**的存储任务，较新闪存块承担更多写任务。

## 3.5 高速缓冲存储器 Cache

### 3.5.1 Cache 基本原理

#### 局部性原理

时间局部性：一个内存位置被重复引用
空间局部性：一个内存位置被引用后，其附近的位置也很快被引用

由于存在空间局部性，所以 Cache 是一种高效的设置。

![](/static/images/blog/2025/408-co/Pasted%20image%2020250816180809.webp)

对于连续排列的数组数据，按列优先访问的形式 B（会跳着访问），显然**空间局部性**更差。

而正常连续访问的方式 A 的访问时间会短，因为周围数据都在 Cache 中。

#### 性能分析

1. Cache 和 主存同时访问
2. Cache 未命中之后，再访问主存
   ![](/static/images/blog/2025/408-co/Pasted%20image%2020250816181318.webp)

#### 按块交换

1. 将主存的存储空间“分块”，e.g. 每1KB为一块。
2. 主存与 Cache 之间以**块**为单位进行数据交换。
   1. Cache块**大小**与主存块大小相同
      1. 但是**数量**不同，故主存块号和 Cache块号（行号）的位数不同
   2. 注意，CPU 与 Cache或主存 之间以**字**为单位传送信息

![](/static/images/blog/2025/408-co/Pasted%20image%2020250816182226.webp)

自然地，**主存地址**由**块号** + **块内地址**组成。

- 主存地址就是主存物理地址

#### Cache 行

- 计算题：**Cache 容量**、地址映射表大小

一个 Cache 行分为： **控制算法位** + **数据部分**

- 控制算法位：有效位 + 替换算法位 + 脏位 + 标记位（tag）
  - **地址映射表**就是指所有行的控制算法位
  - 脏位也叫一致性维护位
  - 不同的映射算法，标记位长度也不同

$$\text{Cache 容量} = \text{Cache 行位数} * \text{行数}$$

Cache 冲突：两个主存单元映射到同一个 Cache 行

- 对于组相联，同一组号即算冲突

### 3.5.2 Cache 与主存的映射

三种映射方式：

1. 全相联映射：任意位置
2. 直接映射：每个主存块有一个特定的位置
3. 组相联映射：每个主存块可以放到一个特定的组

![](/static/images/blog/2025/408-co/Pasted%20image%2020250816220632.webp)

注意，不仅需要标记位，还需要有效位。

#### 全相联映射

1. 主存地址的前22位对比 Cache 中的**所有**块的标记 1. 主存块号（高22位）在 Cache 中 且有效位 = 1，则 Cache 命中。2. 未命中则正常访问主存
   ![](/static/images/blog/2025/408-co/Pasted%20image%2020250816221404.webp)

#### 直接映射

1. 根据主存块号的后3位确定 Cache 行
   1. 若主存块号的前19位与Cache标记匹配 且 有效位 = 1，则 Cache 命中
   2. 若未命中或有效位=0，则正常访问主存

![](/static/images/blog/2025/408-co/Pasted%20image%2020250816221704.webp)

- 缺点：不同主存块对应同一 Cache 位置时，浪费其余空闲空间
- 由于**块在 Cache 中的位置**恰对应**主存块号的低3位**，所以**标记位**只用存19位。- 主存块号 = 标记位 + Cache行号
  ![](/static/images/blog/2025/408-co/Pasted%20image%2020250816222329.webp)

#### 组相联映射

1. 根据主存块号的**后2位**确定所属**分组号**
   1. 若主存块号的前20位与分组内的某个标记匹配且有效位 = 1， 则 Cache 命中
   2. 若未命中或有效位=0，则正常访问主存

![](/static/images/blog/2025/408-co/Pasted%20image%2020250816222830.webp)

- 2路组相联映射：2块一组
- 组相联综合性能最好
- 主存块号 = 标记位 + Cache组号

### 3.5.3 Cache 替换算法

1. 随机算法
2. 先进先出 FIFO
   ![](/static/images/blog/2025/408-co/Pasted%20image%2020250818153217.webp)
3. 近期最少使用 LRU 1. Least Recently Used 2. 基于局部性原理，性能最好 3. 规则 1. 命中时，所命中的行的计数器清零，**比其低的计数器加 1，其余不变** 2. 未命中且有空闲行时，新装入行的计数器置 0，其余非空闲行全加 1 3. 未命中且无空闲行时，计数值最大的行被淘汰，新装行的计数器置 0，其余全加 1
   ![](/static/images/blog/2025/408-co/Pasted%20image%2020250818154228.webp)
4. 最不经常使用 1. Least Frequently Used 2. 规则 1. 新调入的块计数器置 0，之后每被访问一次计数器 + 1 2. 需要替换时，选择计数器最小的一行
   ![](/static/images/blog/2025/408-co/Pasted%20image%2020250818154149.webp)

实际做题中，不用模拟计数器，替换的时候按照策略很容易判断哪个该替换。

### 3.5.4 Cache 写策略

CPU 对 Cache 的写操作可能导致 Cache 与主存的数据不一致，为了解决这个一致性问题，引入了以下的写策略。

#### 写命中

1. 写回法
   1. write-back，适合访问密集
   2. 当 CPU 对 Cache 写命中时，只修改 Cache 的内容，而不立即写入主存，只有当此块**被换出时才写回主存**
      1. 用**脏位**标记 Cache 块是否被修改，修改过的才需要写回
2. 全写法1. 写直通法，write-through，适合安全性高2. 当CPU对Cache写命中时，必须把数据**同时写入Cache和主存** 1. 一般使用**写缓冲**（write buffer）访存次数增加，速度变慢，但更能保证数据一致性 1. 使用写缓冲，CPU 写的速度很快，若写操作不频繁，则效果很好。若写操作很频繁， 可能会因沩写缓冲饱和而发生阻塞
   ![](/static/images/blog/2025/408-co/Pasted%20image%2020250818155516.webp)

#### 写未命中

1. 写分配法
   1. write-allocate
   2. 当CPU对Cache写不命中时，把主存中的块**调入Cache， 在Cache中修改**。
   3. 搭配**写回法**使用
2. 非写分配法
   1. not-write-allocate
   2. 当CPU对Cache写不命中时**只写入主存**，不调入Cache。
   3. 搭配**全写法**使用

### 3.5.5 其他

#### 3.5.5.1 多级 Cache

![](/static/images/blog/2025/408-co/Pasted%20image%2020250818161243.webp)

#### Cache 比较器

1. 几路组相联需要几个比较器
2. 比较器位数 = 标记位位数

## 3.6 虚拟存储器

- 主存和辅存的关系可类比 Cache 和主存

主存和辅存构成了虚拟存储器，虚拟存储器具有主存的速度和辅存的容量。

- 虚地址
  - 逻辑地址
  - 用户编程允许涉及的地址
- 实地址
  - 物理地址
  - 对应主存地址空间

CPU 使用虚地址时，先判断这个虚地址是否在主存中

- 已在主存中，则通过地址变换，直接访问实际物理地址
- 不在主存中，则把包含这个地址的一页/段调入主存，再访问
- 主存已满，则采用替换算法

对于虚拟存储器，**访问辅存的代价很大**，所以

- 采用**写回法**，不用每次访问辅存
- 采用全相联映射

### 3.6.1 页式虚拟存储器

- 以页为基本单位
- 主存空间的页称作物理页、实页
- 虚拟空间的页称作虚拟页、虚页

页表实现了**虚拟地址**到**物理地址**的转换。

#### 快表 TLB

快表就是页表的 Cache，存放经常访问的页。

# 4 指令系统

## 4.1 指令基础

### 4.1.1 ISA

指令系统是**指令集体系结构（ISA)** 中最核心的部分。

ISA 规定的内容主要包括：

- **指令格式，指令寻址方式，操作类型**，以及每种操作对应的操作数的相应规定
- **操作数的类型，操作数寻址方式**，以及是按大端方式还是按小端方式存放
- 程序可访问的**通用寄存器**编号、个数和位数，**存储空间**的大小和编址方式
- 指令执行过程的**控制方式**等，包括程序计数器、条件码定义等

### 4.1.2 指令基本格式

- 指令 = 操作码 + 地址码
- 指令一般是字节大小的整数倍！

指令系统主要有以下四种常见的分类。

#### 按地址码分类

零地址
![](/static/images/blog/2025/408-co/Pasted%20image%2020250819163351.webp)

一地址
![](/static/images/blog/2025/408-co/Pasted%20image%2020250819162234.webp)

二三地址
![](/static/images/blog/2025/408-co/Pasted%20image%2020250819162335.webp)

四地址
![](/static/images/blog/2025/408-co/Pasted%20image%2020250819163330.webp)

#### 按指令长度分类

- **指令字长**：一条指令的总长度（可能会变）
- 机器字长：CPU进行一次整数运算所能处理的二进制数据的位数（通常和ALU直接相关）
- 存储字长：一个存储单元中的二进制代码位数（通常和MDR位数相同）

**半字长指令、单字长指令、双字长指令**：指令长度是**机器字长**的多少倍。

指令字长会影响取指令所需时间。例如，如果机器字长=存储字长=16bit，则取一条双字长指令需要**两次访存**。

指令字结构：

- **定长**指令字结构：指令系统中所有指令的长度都相等。
- **变长**指令字结构：指令系统中各种指令的长度不等。

#### 按操作码长度分类

1. 定长操作码
   1. 指令系统中所有指令的操作码长度都相同。
   - 特点：n位 $\rightarrow$ $2^n$ 条指令。
   - 优点：控制器的译码电路设计简单。
   - 缺点：灵活性较低。
2. 可变长操作码
   1. 指令系统中各指令的操作码长度可变。
   - 特点：不同指令的操作码长度不同。
   - 优点：灵活性较高。
   - 缺点：控制器的译码电路设计复杂。

#### 扩展操作码指令格式

**定长**指令字结构 + **可变长操作码** $\rightarrow$ 扩展操作码指令格式

这种格式结合了**定长**和**变长操作码**的优点，既保持了一定的灵活性，又简化了译码电路的设计。

#### 按操作类型分类

1. 数据传送类
   1. 进行主存与CPU之间的数据传送
      - **LOAD**：作用是把存储器中的数据放到寄存器中。
      - **STORE**：作用是把寄存器中的数据放到存储器中。
2. 运算类
   1. 算术逻辑操作
      - **算术运算**：包括加、减、乘、除、增1、减1、求补、浮点运算等
      - **逻辑运算**：包括与、或、非、异或、位操作、位测试、位清除、位求反等
   2. 移位操作
      - 包括算术移位、逻辑移位、循环移位（带进位和不带进位）。
3. 程序控制类
   1. 转移操作，改变程序执行的顺序
      - **无条件转移**：JMP
      - **条件转移**：
        - JZ：结果为0时转移
        - JO：结果溢出时转移
        - JC：结果有进位时转移
      - **调用和返回**：CALL和RETURN
      - **循环**
      - **陷阱(Trap)与陷阱指令**
4. 输入输出类（I/O）
   1. 输入输出操作：进行CPU和I/O设备之间的数据传送
      - CPU寄存器与IO端口之间的数据传送（端口即IO接口中的寄存器）。

### 4.1.3 扩展操作码

- 不允许短码是长码的前缀
- 设计思路：从地址码最多的开始分配

e.g. 15 15 15 16
![](/static/images/blog/2025/408-co/Pasted%20image%2020250819165302.webp)

e.g. 15 12 62 32
![](/static/images/blog/2025/408-co/Pasted%20image%2020250819172011.webp)

![](/static/images/blog/2025/408-co/Pasted%20image%2020250819172352.webp)

## 4.2 寻址方式

寻址分为两大类：

- 指令寻址：找下一条指令
- 数据寻址：找本条指令的数据

### 4.2.1 指令寻址

#### 4.2.1.1 PC

程序计数器 PC 指明**下一条**要执行的指令的存放地址

- PC 是当程序执行完一步，自动执行下一句指令的**物理硬件**
- PC + 1 发生在**取指令后**

PC 在 x86中也叫作 IP（Instruction Pointer）

位数计算：

- 若机器按字寻址，PC 给出下一条指令字的访存地址 (指令在内存中的地址)，因此 **PC 的位数取决于存储器的字数**
  - 若存储器有 $2^{16}$ 个字，则 PC 至少要 16 位。
- 若机器按字寻址，指令寄存器 IR 用于接收取得的指令，因此 **IR 的位数取决于指令字长**

#### 顺序 跳跃

指令寻址主要有以下两种情况：

- **顺序寻址**
  - 通过程序计数器 PC + 1，自动形成下一条指令的地址
    - **“1”** 理解为指令字长，实际加的值会因指令长度、编址方式而不同
    - 比如变长指令，需要先读取操作码，判断指令长度，得到“1”是多少
    - 现代计算机通常是按字节编址，若指令字长 16 位，(PC) + 2
- **跳跃寻址**
  - 通过**转移类**指令（如相对寻址）实现，可用来实现程序的条件或无条件转移
    - 跳跃：
      - 指下条指令的地址不由 PC 自动给出，而由本条指令给出下条指令地址的计算方式
  - 跳跃分为：
    - **绝对转移**，地址码直接指出转移目标地址
    - **相对转移**，地址码指出转移目的地址相对于当前 PC 值的偏移量
  - 跳跃的结果是当前指令**修改 PC 值**，下一条指令仍然通过 PC 给出，CPU 总是根据 PC 的内容去主存取指令

### 4.2.2 数据寻址

确定**本条指令**的地址码指明的真实地址

- 表示的是操作数的地址

#### 地址码的组成

地址码按照不同的解读方式，分为 10 种，每种有不同的寻址特征。

- 下图是一地址指令，多地址同理
  ![](/static/images/blog/2025/408-co/Pasted%20image%2020250819203705.webp)

地址码 = 寻址特征 + 形式地址

- **寻址特征**：指明属于那种寻址方式（其位数决定了寻址方式的种类）
- **形式地址 A**：不代表操作数的真实地址，需要根据寻址特征的要求转换为对应存储器的地址
- **有效地址 EA**：通过**寻址特征和形式地址**计算出操作数在存储器中的**真实**地址

A 既可以是寄存器编号，又可以是内存地址；(A) 表示地址为 A 的单元的内容

#### 直接寻址

- 形式地址 `A = 真实地址`
- 有效地址`EA = A`

- 优点：简单，不需要计算操作数的地址，指令在执行阶段仅需**访存 1 次**
- 缺点：A 的位数限制了该指令操作数的寻址范围，操作数的地址不易修改

#### 间接寻址

- 形式地址 `A = 操作数有效地址所在的主存单元的地址`
- 有效地址`EA = (A)`
- 寻址过程：去该主存单元取操作数的地址，再去找操作数

![image.png](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250820010129489.png?imageMogr2/quality/80&imageSlim)

是否是多次间接寻址看操作数的内容第一位是否是1

- 注意，这是区分间接寻址和多次间接寻址的方式；而**寄存器寻址和寄存器间接寻址是直接通过寻址特征区分的**。

- **优点**：可扩大寻址范围，便于编制程序（方便完成子程序的返回）
- **缺点**：指令在执行阶段要多次访存（1 次间址 2 次访存），执行速度较慢

#### 寄存器寻址

- 形式地址 `A = 操作数所在寄存器的编号`
- 有效地址 EA = $R_i$
- 寻址过程：访问该寄存器，取出操作数
  ![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240426165653.png)

- **优点**：
  - 指令在执行阶段**不用访存**，只访问寄存器，执行速度快
  - 指令字长较短
    - 因为寄存器数量远小于内存单元数，地址码位数较少
- **缺点**：
  - 寄存器价格昂贵
  - CPU 的寄存器数量有限

#### 寄存器间接寻址

- 形式地址 `A = 操作数所在的寄存器的地址`
- 有效地址：EA = $(R_i)$
- 寻址过程：根据该地址去寄存器中找到操作数的有效地址
  ![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240426181955.png)

- **优点**：相比间接寻址，既扩大了寻址范围，又减少了访存次数（执行阶段仅访存 1 次）
- **缺点**：相比寄存器访存，执行阶段需要访存（操作数在主存中）

#### 隐含寻址

不直接给出操作数的地址，而是在指令中就隐含操作数的地址。

- 有效地址：程序指定
- 寻址过程：
  - 形式地址 A 取出对应的一个操作数
  - **另一个操作数通过隐含寻址方式的指令设置**，隐含在 ACC 中

![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250820012605428.png?imageMogr2/quality/80&imageSlim)

- **优点**：有利于缩短指令字长
- **缺点**：需增加存储操作数或隐含地址的硬件

#### 立即寻址

- 与直接寻址区分

操作数**本身**直接存放在形式地址中

- 有效地址： A 就是操作数，也称**立即数**
- 寻址过程：
  - 寻址特征为`#`，代表立即寻址的意思
  - 形式地址写的是操作数 3 的补码（011）

![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250820012831119.png?imageMogr2/quality/80&imageSlim)

- **优点**：**不访存**，指令执行速度**最快**
- **缺点**：A 的位数限制了立即数的范围

#### 基址寻址

- 以下三种都是**偏移寻址**：基址、变址、相对
  - 三者的形式地址 A 都表示**偏移量**
  - 三者的区别在于**偏移的起点**（基地址）

基地址是基址寄存器（Base address Register）的内容

- 有效地址 `EA = (BR) + A`
- 寻址过程：程序运行前，CPU 将 BR 的值修改为程序的起始地址（存放在操作系统 PCB 中 ）

![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250820143904141.png?imageMogr2/quality/80&imageSlim)

- **基址寄存器**：
  - OS中的重定位寄存器 = 基址寄存器
  - 基址寄存器可以是一个专用寄存器，也可以是指定的某个**通用**寄存器
  - **面向操作系统**，内容由**操作系统**或管理程序确定，用于解决程序逻辑空间与存储器物理空间的无关性
  - 程序执行过程中，基址寄存器内容不变（作为基地址），形式地址可变（作为偏移量）
  - 采用通用寄存器时，可由用户决定哪个寄存器，但**其内容仍由操作系统确定**
    - 需要额外占用若干bit指明需要哪个通用寄存器
- **优点**：
  - 可以扩大寻址范围（基址寄存器的位数大于 A 的位数）
  - 用户不用操心程序的内存位置，只管写程序即可
    - 有利于**多道程序设计**
      - 多道程序设计：在一台计算机的内存中，同时装入**多道程序**（多个作业）
    - 可用于**编制浮动程序**
- **缺点**：偏移量（A）的位数较短

#### 变址寻址

与基址类似，区别是：

1. 变址寄存器的内容可以被**用户**修改
2. 形式地址作为**基地址**，而变址寄存器的内容作为**偏移量**

- 有效地址 `EA = A + (IX)`

- **优点**：
  - 可以扩大寻址范围
    - 变址寄存器的位数大于 A 的位数
  - 适合**循环程序**
    - 在**数组处理**过程中，可设定 A 为数组的首地址，不断改变 IX 的内容，便可很容易形成数组中任意一个数据的地址
  - 偏移量的位数足以表示整个存储空间

基址 + 变址 的复合寻址：

1. 先基址寻址：`EA = (BR) + A`
2. 再变址寻址：`EA = A + (IX)`
3. 最终有效地址：`EA = ((BR) + A) + (IX)`

#### 相对寻址

基地址是 PC 的内容

- 有效地址：EA = (PC) + A
  - A 可正可负，**补码表示**
  - A 的位数决定操作数的寻址范围

![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250820154742396.png?imageMogr2/quality/80&imageSlim)

- **优点**：
  - 操作数的地址不是固定的，随 PC 值的变化而变化，与指令地址之间总是相差一个固定的偏移量，因此**便于程序浮动**
    - e.g. 一段for循环代码移动位置
      ![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250820152126211.png?imageMogr2/quality/80&imageSlim)
  - 广泛应用于**转移指令**

#### 堆栈寻址

操作数存放在堆栈中，隐含使用堆栈指针 SP 作为操作数地址

- SP：Stack Pointer 是一个寄存器

e.g. 一次加法操作的堆栈寻址
![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250820162432908.png?imageMogr2/quality/80&imageSlim)

- 有效地址：99入栈 / 出栈时 EA 的确定方式不同
- **堆栈**：
  - 后进先出的一块存储区
  - 该存储区中被读 / 写单元的地址是用堆栈指针 SP 给出
  - 硬件自动完成 SP 的加减操作
    ![300](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250820160944298.png?imageMogr2/quality/80&imageSlim)
  - **硬堆栈**：寄存器堆栈，成本较高，**不需要访存**，不适合做大容量堆栈
  - **软堆栈**：从**主存**中划出一段区域，执行阶段访存 1 次，通常采用软堆栈

#### 总结

- 速度方面：立即寻址 > 寄存器寻址 > 直接寻址 > 寄存器间接寻址 > 间接寻址

![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250820161213887.png?imageMogr2/quality/80&imageSlim)

注意，以上的访存次数是指指令执行期间，不包括取指令。

### 4.2.3 补充：硬件的比较跳转

![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250820160033411.png?imageMogr2/quality/80&imageSlim)

## 4.3 机器代码

- 汇编基础：[第二章 寄存器](汇编语言.md#第二章%20寄存器)

寄存器：
![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250820204215735.png?imageMogr2/quality/80&imageSlim)

### 4.3.1 数据传送类

- `MOV dst, src`：传送数据（寄存器/内存/立即数之间）
- `PUSH src`：把操作数压栈（SP/ESP 减小，内容写入栈顶）
- `POP dst`：把栈顶弹出到寄存器/内存（SP/ESP 增大）
- `XCHG dst, src`：交换两个操作数的值
- `LEA reg, mem`：取内存操作数的有效地址加载到寄存器（常用来计算地址偏移）

### 4.3.2 算术运算类

- `ADD dst, src`：加法
- `SUB dst, src`：减法
- `INC dst`：加 1increase
- `DEC dst`：减 1decrease
- `MUL src`：无符号乘法（默认和 AX/EAX 相乘）
  - `IMUL src`：有符号乘法
- `DIV src`：无符号除法（默认被除数在 AX 或 DX\:AX 中）
  - `IDIV src`：**有符号**除法
  - EDX = EAX / src，商存入 EAX，余数存入 EDX
- `NEG dst`：取负数
- `CMP dst, src`：比较（本质是 `SUB`，结果不保存，只改标志位）

### 4.3.3 逻辑运算类

- `AND dst, src`：按位与
- `OR dst, src`：按位或
- `XOR dst, src`：按位异或
  - Exclusive OR
- `NOT dst`：按位取反
- `TEST dst, src`：按位与，只影响标志位，不保存结果

### 4.3.4 移位/循环移位类

- `SHL dst, n`：逻辑左移
  - Shift Left
  - 将 dst 左移 n 位，放回 dst
- `SHR dst, n`：逻辑右移（高位补 0）
- `SAL dst, n`：算术左移
- `SAR dst, n`：算术右移（高位补符号位）
- `ROL dst, n`：循环左移
- `ROR dst, n`：循环右移
- `RCL dst, n`：带进位循环左移
- `RCR dst, n`：带进位循环右移

### 4.3.5 转移控制类

#### 4.3.5.1 无条件转移

- `JMP label`：无条件跳转

#### 条件转移（重点）

根据 **标志寄存器（ZF, CF, SF, OF 等）** 跳转：

- `JE/JZ label`：等于 / 为零时跳转
- `JNE/JNZ label`：不等于 / 非零时跳转
- `JC`：进位时跳转
- `JNC`：无进位时跳转
- `JS`：负数（符号位=1）时跳转
- `JNS`：非负时跳转
- `JG/JNLE`：大于（有符号）
  - Jump when Greater than
- `JGE`：大于等于
  - Jump when Greater than or Equal to
- `JL/JNGE`：小于（有符号）
- `JLE`：小于等于
  - Jump when Less than or Equal to
- `JA`：大于（无符号）
- `JB`：小于（无符号）

e.g. 一个 if 判断
![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250820205937497.png?imageMogr2/quality/80&imageSlim)

e.g. 循环
![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250820210631851.png?imageMogr2/quality/80&imageSlim)

- `LOOP`：等价于 自减 + 比较 + 跳转
  - 指定 ECX 作为

![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250820210847811.png?imageMogr2/quality/80&imageSlim)

### 4.3.6 子程序调用与返回

- `CALL label`：调用子程序（把返回地址压栈，然后跳转）
- `RET`：从子程序返回（把返回地址弹栈，跳回调用点）
- `INT n`：软中断
- `IRET`：中断返回

当前函数的栈帧位于**栈顶**：

- **栈顶是低地址**，栈从高往低增长
- x86 系统中，默认以**4字节**为栈的操作单位
  ![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250820211611950.png?imageMogr2/quality/80&imageSlim)

call ret 具体过程：

1. call
   1. 把 IP（原函数下一条指令位置）压栈
   2. 设置新 IP
   3. 显式：这一步可以用 ENTER 命令替代
      1. push 原函数的 EBP
      2. 设置新函数栈底
2. leave
   1. 效果是让 EBP 和 ESP 指向上一层函数的栈底和顶
      ![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250820213324559.png?imageMogr2/quality/80&imageSlim)
3. ret 1. 把 IP 旧值出栈
   ![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250820211926699.png?imageMogr2/quality/80&imageSlim)

### 4.3.7 栈帧内部详解

![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250820215112867.png?imageMogr2/quality/80&imageSlim)

区域内部实现从低往高增长：

- 局部变量区：越先定义的变量，越靠近**栈顶**，自顶向底是从低往高
- 调用参数区：越靠前的参数，越靠近栈顶

e.g. 汇编代码过程
![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250820221259841.png?imageMogr2/quality/80&imageSlim)

### 4.3.8 其他

- 非重点

1. 字符串处理

- `MOVS`：内存块传送
- `LODS`：装载字符串元素
- `STOS`：存储字符串元素
- `SCAS`：扫描字符串
- `CMPS`：比较字符串

2. 标志寄存器相关

- `CLC`：清进位标志 CF=0
- `STC`：置进位标志 CF=1
- `CLD`：清方向标志（DF=0，字符串操作自增）
- `STD`：置方向标志（DF=1，字符串操作自减）

### 4.3.9 补充 AT&T 格式

- 一般不考

![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250820205152942.png?imageMogr2/quality/80&imageSlim)

## 4.4 CISC 和 RISC

### 4.4.1 复杂指令系统计算机（CISC）

- **Complex Instruction Set Computer**
- 设计思路：一条指令完成一个复杂的基本功能
- 代表：x86 架构，主要用于笔记本、台式机等
- 指令系统：复杂庞大
- 指令数目：一般大于 200 条
- 指令字长：不固定，指令格式多，寻址方式多
- 可访存指令：不加限制
- 各种指令执行时间：相差较大，大多数指令需要多个时钟周期才能完成
- 各种指令使用频度：相差很大
- 通用寄存器数量：较少
- 目标代码：难以用优化编译生成高效的目标代码程序
- 控制方式：绝大多数为微程序控制
- 指令流水线：可通过一定方式实现
- 兼容性：可兼容很多不同的高级语言和软件

### 4.4.2 精简指令系统计算机（RISC）

- **Reduced Instruction Set Computer**
- 设计思路：一条指令完成一个基本“动作”，多条指令组合完成一个复杂的基本功能
- 代表：
  - ARM 架构，手机、平板等
  - MIPS 架构，五段式流水线
- 指令系统：简单精简
- 指令数目：一般小于 100 条
- 指令字长：定长，指令种类少，寻址方式种类少
- 可访存指令：只有 Load / Store 指令
- 各种指令执行时间：绝大多数在一个周期内完成
- 各种指令使用频度：都比较常用
- 通用寄存器数量：多
- 目标代码：采用优化的编译程序，生成代码较为高效
- 控制方式：绝大多数为组合逻辑控制，硬布线
- 指令流水线：必须实现
- 兼容性：较差

和 CISC 相比，RISC 的优点体现在：

- RISC 更能充分利用 VLSI（超大规模集成电路）芯片的面积
- RISC 更能提高运算速度
- RISC 便于设计，可降低成本，提高可靠性
- RISC 有利于编译程序代码优化

# 5 中央处理器 CPU

## 5.1 CPU概述

### 5.1.1 CPU 的功能

1. 指令控制：
   - 完成取指令、分析指令和执行指令的操作，即程序的顺序控制
2. 操作控制：
   - 管理并产生由内存取出的每条指令的操作信号
   - 把各种操作信号送往相应的部件，从而控制这些部件按指令的要求进行动作
3. 时间控制：
   - 严格控制各种操作信号的出现时间、持续时间及出现的时间顺序
4. 数据加工：
   - 对数据进行算术和逻辑运算
5. **中断处理**：
   - 对计算机运行过程中出现的异常情况和特殊请求进行处理

### 5.1.2 CPU 的基本结构

1. `CPU = 运算器 + 控制器`
   - 运算器：对数据进行加工
   - 控制器：负责协调并控制计算机各部件执行程序的指令
   - 又可以细分为 `ALU + CU + 寄存器 + 中断系统`
2. `CPU = 数据通路 + 控制部件`

![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250821233153067.png?imageMogr2/quality/80&imageSlim)

- 结合后面几个小节理解

### 5.1.3 CPU 寄存器

- 2010真题

按汇编语言（或机器语言）程序是否可以访问分类。

用户可见的寄存器：

- 可对这类寄存器编程
- 使用这类寄存器可减少对主存储器的访问次数
- **通用寄存器（含基址 / 变址）、程序状态字寄存器PSW、状态 / 标志寄存器、程序计数器PC、累加寄存器ACC**

用户不可见的寄存器：

- 对用户透明（**透明是指不可见**），不可编程
- 被控制部件使用，以控制 CPU 的操作
- **存储器地址寄存器MAR、存储器数据寄存器MDR、指令寄存器IR、暂存寄存器、移位寄存器**

### 5.1.4 运算器

运算器是计算机对数据进行加工处理的中心，接收从控制器送来的命令并执行相应的动作，对数据进行加工和处理。

#### 运算器组成

- 算术逻辑单元（ALU）
  - 进行算术 / 逻辑运算
- 通用寄存器组（GPRS）
  - 如 AX，BX，CX，DX，SP
  - 用于存放操作数和各种地址信息，所以其位数与机器字长相等
  - SP 是堆栈指针，用于指示栈顶的地址
- **暂存寄存器**
  - 暂存从数据总线或通用寄存器读来的操作数
    ![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250821230918991.png?imageMogr2/quality/80&imageSlim)
  - 对应用程序员透明
- **累加寄存器**（ACC）
  - 是一个通用寄存器
  - 暂放 ALU 运算的结果信息，可作为加法运算的输入端
- 程序状态字寄存器（PSW）
  - PSW 存放程序状态字（标志位的组合），用于保存系统的运行状态
  - PSW 包括状态标志和控制标志
  - 溢出标志 OF，符号标志 SF，零标志 ZF，进位标志 CF
  - 中断标志，陷阱标志
- 移位寄存器（SR）
  - 对操作数或运算结果进行移位运算
- 计数器
  - 控制乘除运算的操作步数

### 5.1.5 控制器

控制器负责协调并控制计算机各部件工作。

控制器的基本功能：

- 取指令
- 分析指令
  - 操作码译码（分析本条指令要完成什么操作），产生操作数的有效地址
- 执行指令
  - 根据分析指令得到的“操作命令”和“操作数地址”，形成操作信号控制序列
- **中断处理**
  - 管理总线及输入输出；处理异常情况（如掉电）和特殊请求（如打印机请求打印一行字符）

#### 控制器组成

- 程序计数器（PC）
  - 用于指出**下一条**指令在主存中的存放地址（PC 总是存放指令地址）
  - PC 有自增功能
    - 机器指令中不能显式地使用PC
  - PC 的值会根据 CPU 在执行指令过程中自增或转移到程序的某处 (跳转指令)
  - `PC 的位数 = 主存储器（按照指令编址）的地址位数`，因为 PC 就是存地址的
    - \*\*注意，不一定按字节编址，地址就是取字节地址；如果指令按字边界对齐，则指令取字地址，这样位数更短，2016真题。
- 指令寄存器（IR）
  - 用于保存当前**正在**执行的那条指令
  - `IR 的位数 = 指令字长` （大于等于）
- 指令译码器（ID）
  - 仅对**操作码**字段进行译码，以确定指令的操作功能
- 存储器地址寄存器（MAR）
  - 存放要访问的主存储器单元的地址
  - `MAR 的位数 = 主存储器地址线位数`
- 存储器数据寄存器（MDR）
  - 存放向主存储器写入的信息或从主存储器读出的信息
  - `MDR 的位数 = 存储字长`
- 微操作信号发生器
  - 根据 IR 的内容 (指令)，PSW 的内容 (状态信息) 和时序信号**产生控制计算机系统所需的各种控制信号**
  - 有组合逻辑型和存储逻辑型
  - **2022真题：控制信号由什么部件产生？答：CU**
    - CU是更笼统的一个概念
- 时序系统
  - 用于产生各种时序信号，都由统一时钟 CLOCK 分频得到

### 5.1.6 数据通路概述

- 详见后文

#### 专用数据通路方式

根据指令执行过程中的数据和地址的流动方向安排连线线路

- 使用多路选择器控制一路的输出
- 使用**三态门**控制输出
- **优点**：性能较高，基本不存在数据冲突现象
- **缺点**：结构复杂，硬件量大，不易实现

#### CPU 内部单总线方式

将所有寄存器的输入端和控制端都连接到一条公共通路

- **优点**：结构简单，容易实现
- **缺点**：
  - 传输存在较多冲突现象，性能较低
  - 需要暂存寄存器

## 5.2 指令执行

### 5.2.1 指令周期

指令周期 = 取指周期 + 执行周期
![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250821234027775.png?imageMogr2/quality/80&imageSlim)

#### 周期概念辨析

几个周期的关系：

1. 若干 **CPU 时钟周期 / 节拍 / CLK / T周期** 组成 一个机器周期
2. 若干机器周期 组成 一个指令周期

![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250821234408903.png?imageMogr2/quality/80&imageSlim)

常见指令的指令周期：
![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250822001631386.png?imageMogr2/quality/80&imageSlim)

- 可能额外含有间址和中断

#### 指令周期流程

![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250822002239800.png?imageMogr2/quality/80&imageSlim)

- 用触发器区分是哪个周期
  - FE Fetch、IND Indirect、EX Execute、INT Interrupt
- 四种周期都有**访存**操作

### 5.2.2 指令周期的数据流

**数据流**：根据指令要求一次访问的数据序列

- 指令执行不同阶段，访问的数据序列不同
- 不同的指令，数据流也不同

#### 取指周期

根据 PC 中的内容从主存中**取出指令代码并放在 IR 中**

数据流向：

1.  PC to MAR（ to 地址总线 to 主存）
    1.  MAR 送到 主存是*MAR寄存器的固有功能，一旦地址存入MAR，其输出便持续有效并连接到地址总线上，通常不需要一个独立的“MARout”控制信号*
2.  CU 发出读命令 to 控制总线 to 主存
3.  主存 to 数据总线 MDR to IR
4.  CU 发出控制信号 to PC + 1

![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240428160538.png)

#### 间址周期

取操作数的有效地址

以一次间址为例，将指令中的地址码送到 MAR 并送至地址总线，此后 CU 向存储器发出读命令，以获取有效地址并存至 MDR。

数据流向：

1. Ad(IR / MDR) to MAR to 地址总线 to 主存
   1. IR、MDR都有地址码，**考试写 IR**
2. CU 发出读命令 to 控制总线 to 内存
   1. 用形式地址去读有效地址
3. 主存 to 数据总线 to MDR
   1. **成功读出有效地址，并存放在MDR**
4. 有效地址 to 指令的地址码字段

![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240429162059.png)

#### 执行周期

取操作数，并根据 IR 中的指令字的操作码通过 ALU 操作产出执行结果

数据流向：不同指令操作不同，无统一的数据流向

#### 中断周期

处理中断请求

假设程序断点存入堆栈中，并用 SP 指示栈顶指针，而且进栈操作是先修改指针，后存入数据；出栈操作是先删除数据，后修改指针。

数据流向：

1. CU 控制 SP - 1，修改后的 SP to MAR to 地址总线 to 主存
   1. 进栈需要先修改栈顶指针
2. CU 发出写命令 to 控制总线 to 主存
3. PC to MDR to 数据总线 to 主存
   1. **保存断点（PC）到栈顶（SP）**
4. CU 修改 PC 为中断服务程序的入口

![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240429162754.png)

### 5.2.3 指令的执行方案

#### 5.2.3.1 单周期处理器

每条指令都在**一个**时钟周期内完成，CPI = 1。

指令周期**取决于执行时间最长的指令**的执行时间。

特点：

- 串行，相同执行时间
- 部件冗余大，时间利用率低
- **指令执行时，控制信号不变**
  - 单总线结构一个时钟只能完成一个操作，故不可以用单总线结构

#### 多周期处理器

每条指令在多个时钟周期完成，每条的周期数可以不同，但是一定大于1（CPI > 1）。

- 特点：串行，不同执行时间
- **注意，多周期和单周期的时钟周期的长度可能不同**

#### 流水线处理器

在每一个时钟周期启动一条指令，尽量让多条指令同时运行，但各自处在不同的执行步骤中。

尽量让多条指令同时运行，但各自处在不同的执行步骤中。

- 特点：**并行**

## 5.3 数据通路

总线概念辨析：

- 内部总线
  - CPU**内部**连接CPU的各个核心部件
- 系统总线
  - CPU与计算机**其他主要部件**（如内存、I/O设备）之间的数据传输

数据通路的两类元件：

1. 操作元件
   1. 组合逻辑元件
   2. ALU、MUX、译码器、加法器、三态门等
2. 状态元件
   1. 时序逻辑元件
   2. 各类寄存器、存储器，包括通用寄存器组、PC、状态/移位/暂存/锁存寄存器

### 5.3.1 数据通路的基本结构

#### 5.3.1.1 单总线结构

- CPU 内部单总线

将所用寄存器的输入端与输出端连接到**一条公共通路**上

- 结构比较简单
- 同一时间**只能有一个输出**，可以有多个输入（两个部件之间交换）
- 数据传输存在较多的**冲突**现象，性能较低

![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240429184829.png)

- in 表示该部件的允许输入控制信号；out 表示该部件的允许输出控制信号
- **ALU 只能有一个输入端与总线相连**，另一个输入端需要**通过暂存器**与总线相连

#### 多总线结构

- CPU 内部多总线方式

将所用寄存器的输入端与输出端都连接到**多条公共通路**上

- 相较单总线结构，**效率较高**

#### 专用数据通路

根据指令执行过程中的数据和地址的**流动方向**安排连接线路

- 避免使用共享的总线，**性能较好**，但**硬件总量较大**

### 5.3.2 单总线

以 CPU 内部单总线数据通路为例，注意每次总线传送时哪些信号有效。

1. 寄存器之间数据传送

   - e.g. 把 **PC 内容送至 MAR**，实现传送操作的流程及控制信号为：
     - (PC) -> Bus
       - PCout 有效，PC 内容送至总线
     - Bus -> MAR
       - MARin 有效，总线内容送 MAR

2. 主存与 CPU 之间的数据传送
   - e.g. **CPU 从主存读取指令**，实现传送操作的流程及控制信号为：
     - (PC) -> Bus -> MAR
       - PCout 和 MARin 有效，现行指令地址 -> MAR
     - 1 -> R
       - CU 发**读命令**
         - “1”： 代表一个控制信号，高电平
         - “R”： Read
     - MEM (MAR) -> MDR
       - MDRin 有效
     - MDR -> Bus -> IR
       - MDRout 和 IRin 有效，现行指令 -> IR

![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250822151600750.png?imageMogr2/quality/80&imageSlim)

3. 执行算术或逻辑运算
   - 比如一条**加法指令**，微指令序列及控制信号为：
     - Ad (IR) -> Bus -> MAR
       - **MDRout** 和 Yin 有效
       - 从 IR 和 MDR 都可以取到地址，因为指令是从 MDR 复制到 IR 的
     - 1 -> R
       - CU 发读命令
     - MEM (MAR) -> 数据线 -> MDR
       - MDRin 有效
     - MDR -> Bus -> Y
       - MDRout 和 Yin 有效，操作数 -> Y
     - (ACC) + (Y) -> Z
       - ACCout 和 ALUin 有效，CU 向 ALU 发送加命令
     - Z -> ACC
       - Zout 和 ACCin 有效，结果 -> ACC

#### 单总线分析题

1. 先分析指令功能和指令周期
2. 写各个周期的操作和信号

取指周期：
![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250822153308233.png?imageMogr2/quality/80&imageSlim)

间址周期：
![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250822153803410.png?imageMogr2/quality/80&imageSlim)

执行周期：
![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250822153837757.png?imageMogr2/quality/80&imageSlim)

**考试需要根据题目图的实际情况来写信号，图上没给的信号不要写！**

e.g. 2022真题
![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250823005426082.png?imageMogr2/quality/80&imageSlim)

比如本题未给出**系统总线**的 MDRin，故READ时，答案没有写 MDRin 信号

### 5.3.3 专用数据通路

![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250822154910924.png?imageMogr2/quality/80&imageSlim)

![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250822155341232.png?imageMogr2/quality/80&imageSlim)

```
存：
(ACC) -> MDR
(MDR) -> M(MAR)
```

![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250822155901115.png?imageMogr2/quality/80&imageSlim)

## 5.4 控制器

CU发出一个微命令，可完成对应微操作。

e.g.

- 微命令 a：使 PCout、MARin 有效
- 完成对应的微操作 a：（PC）to MAR

![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250823152617701.png?imageMogr2/quality/80&imageSlim)

注意：

- 一个节拍内可以并行完成多个“相容的”微操作
- 同一个微操作可能在不同指令的不同阶段被使用
- 不同指令的执行周期所需节拍数各不相同
  - 为了简化设计，选择定长的机器周期，以可能出现的最大节拍数为准（通常以访存所需节拍数作参考）
- 若实际所需节拍数较少，可将微操作安排在机器周期末尾几个节拍上进行
  - 见上图的执行、中断周期

### 5.4.1 硬布线控制器

- 基本不考

**根据 指令操作码、目前的机器周期、节拍信号、机器状态条件，即可确定现在这个节拍下应该发出哪些“微命令”。**

![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250823153216542.png?imageMogr2/quality/80&imageSlim)

比如，对于所有指令的取指周期，在 T0 节拍下一定要完成 (PC) to MAR。则可知逻辑表达式为 $C_{1} = FE*T_{0}$，而 $C_{1}$ 就是一组微命令的代表。

硬布线控制器的特点：

- 由于纯硬件实现、设计复杂，因此一般用于指令较少的 RISC（精简指令集系统）
- 如果扩充一条新的指令，则控制器的设计就需要大改，因此扩充指令较困难
- 由于使用纯硬件实现控制，因此**执行速度很快**。微操作控制信号由组合逻辑电路即时产生

### 5.4.2 微程序控制器

- 难点，但是非重点
- 引入了软件的思想

#### 概念辨析

程序：由**指令**（序列）组成

- 指令：对程序执行步骤的描述

同时，每一种（机器）**指令**对应一个**微程序**。

- 注意，这个说法是正确的，后文会有关于微程序段的概念，勿混淆

微程序：由**微指令**（序列）组成

- 微指令：对指令执行步骤的描述
  - 微指令就是类比指令构建的

![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250823163216175.png?imageMogr2/quality/80&imageSlim)

补充**微程序段**：

- 通常，一条机器指令对应一个微程序。
- 但是，由于任何机器指令的取指令操作都是相同的，因此可将**取指周期的微命令统一编成一个微程序段，作为公用**，这个微程序段只负责将指令从主存单元中取出并送至指令寄存器。
  - 所以会有题目说：如果某指令系统中有 $n$ 条机器指令，则 CM 有微程序段的个数至少是 $n+1$ 个
- 此外，也可编出对应间址周期的微程序段和中断周期的微程序段。

**微指令、微命令、微操作**

- 微命令：微程序控制器中控制部件发出的**控制信号**
- 微命令和微操作一一对应
- 一个微指令中可能包含多个微命令/微操作

#### 微程序控制器的结构

![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250823163930201.png?imageMogr2/quality/80&imageSlim)

- 控制存储器由 ROM 组成

#### 微程序控制单元设计

- 基本不考
- 比硬布线设计方便

![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250823174803798.png?imageMogr2/quality/80&imageSlim)

#### 微程序 对比 硬布线

- 重点

|          | 微程序控制器                                       | 硬布线控制器                                                         |
| -------- | -------------------------------------------------- | -------------------------------------------------------------------- |
| 工作原理 | 微操作控制信号以**微程序**的形式存放在控制存储器中 | 微操作控制信号由**组合逻辑电路**根据当前的指令码、状态和时序即时产生 |
| 执行速度 | 慢                                                 | 快                                                                   |
| 规整性   | 较规整                                             | 烦琐、不规整                                                         |
| 应用场合 | CISC CPU                                           | RISC CPU                                                             |
| 易扩充性 | 易扩充修改                                         | 困难                                                                 |

### 5.4.3 微指令

#### 5.4.3.1 格式

1. 水平型（胖子）
   1. 微指令长
      1. 一条微指令能定义**多个**微命令
      2. 微程序短
   2. 编写麻烦，执行速度快
   3. 控制信号经过编码产生
   4. 充分利用**并行**
2. 垂直型（瘦子）
   1. 微指令短
      1. 一条微指令只定义**一个**微命令
      2. 微程序长
   2. 便于编写，执行速度**慢**
   3. 设置了**微操作码**
3. 混合型
   ![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250823170606122.png?imageMogr2/quality/80&imageSlim)

#### 编码方式

- **重点**

1. 直接编码
   1. 一位对应一个微命令
2. 字段直接编码
   1. 分字段
   2. 一字段（译码之后）对应一组互斥的微命令
   3. **每个字段需要保留一个空状态**
3. 字段间接编码 1. 直接是一次译码，间接是二次译码 2. 削弱了并行控制能力
   ![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250823171541284.png?imageMogr2/quality/80&imageSlim)

![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250823172026037.png?imageMogr2/quality/80&imageSlim)

e.g. 例题
![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250823171912784.png?imageMogr2/quality/80&imageSlim)

#### 地址形成方式

- 重点

1. 下地址字段
   1. **断定法**
   2. 直接由微指令的**下地址（后继地址）字段**指出
2. 操作码
   1. 根据机器指令的**操作码**形成
   2. 机器指令取至 IR 后，微指令的地址由操作码由**微地址形成部件**产生
3. 增量**计数器法**
   1. 微地址连续：(CMAR) + 1 -> CMAR
   2. 类似 PC + 1
4. 分支转移
   1. 根据各种标志
5. 测试网络形成
6. 由硬件直接产生微程序入口地址
   1. 第一条微指令地址由**专门的硬件**产生（用专门的硬件记录取指周期微程序首地址）
   2. 中断周期由硬件产生中断周期微程序首地址（用专门的硬件记录）

## 5.5 异常和中断

### 5.5.1 概念

- 异常
  - CPU **内部**产生的意外事件
  - 也称**内**中断
- 中断
  - 来自 CPU **外部的设备**向 CPU 发出的中断请求
  - 也称**外**中断
    - e.g. IO设备（键盘输入）、定时器计数、DMA传送结束

中断和异常的**处理过程**基本相同：

1. CPU 在执行用户的第 $i$ 条指令时，检测到异常 / 发现中断请求
2. CPU 打断当前程序，转去执行异常 / 中断处理程序
   1. 成功解决问题，CPU 执行返回指令，回到被打断的用户程序的第 $i$ 或 $i+1$ 条指令继续执行
   2. 发现是不可恢复的致命错误，终止用户程序

### 5.5.2 异常分类

异常按照**软硬**可以分为：

1. 硬故障中断
   1. 硬连线异常引起
      1. e.g. 总线错误、存储器校验错误
2. 程序性异常
   1. 也称软件中断
   2. CPU 内部执行指令异常
      1. e.g. 整除0、溢出、断点、非法指令、栈溢出、地址越界、缺页

异常按照**原因**可以分为：

1. 故障 Fault
   1. 引起故障的**指令**执行中的异常
   2. 分为是否可恢复
      1. 可恢复，回到**断点**（**当前**发生故障的指令）
         1. 取数时，缺页
      2. 不可恢复，**终止进程**
         1. 译码时，非法操作码
         2. 除法时，除数0
2. 自陷 Trap
   1. 也称陷阱 / 陷入
   2. 一种**预先安排**的异常，通常是在程序中预先写入的特殊指令或者特殊标志，形成一个人为的陷阱，使得 CPU 在执行到陷阱处时，根据不同的陷阱类型转去内核进行相应处理，处理完之后返回到自陷命令的**下一条**。
      1. e.g. 断点调试、单步跟踪、系统调用指令、条件自陷指令
   3. 故障、自陷属于程序性异常（**软件中断**）
3. 终止 Abort
   1. 硬件错误
   2. 终止、外中断属于**硬件中断**
   3. 不是特定指令产生的，是随机发生的

每个细节、例子都要记清楚，就考概念细节。

### 5.5.3 中断分类

中断分为：

1. 可屏蔽中断
   1. 通过**可屏蔽中断请求线 INTR** 向 CPU 发出的中断请求
   2. CPU 通过在中断控制器中设置相应的屏蔽字来选择是否屏蔽（不送到 CPU）
2. 不可屏蔽中断
   1. 通过**专门的不可屏蔽中断请求线 NMI** 向 CPU 发出的中断请求
      1. e.g. 紧急的硬件故障（电源掉电）

中断和异常在本质上相似，不同表现在：

1. 异常（除了终止）与特定指令的执行有关；**中断和任何指令无关**
2. 异常的检测由 CPU 自身完成；中断则必须通过中断请求线获取信息
   1. **所有异常和中断都是由硬件检测发现的**

另外，根据识别中断服务程序地址的方式，可以分为向量中断和非向量中断；根据中断处理过程是否允许被打断，分为单重中断和多重中断。

### 5.5.4 响应过程

1. 关中断
   1. 保存断点时，不能被新的中断打断，**禁止响应新的中断**
      1. 可以通过设置“**中断允许**”（IF）触发器为1，实现开中断，表示允许响应中断
2. 保存断点和程序状态
   1. 保存在栈中
      1. 支持嵌套
      2. PSW 也需要保存
3. 识别异常 / 中断，并转到处理程序
   - **软件识别**
     - CPU 设置一个**异常状态寄存器**，用于记录异常原因
     - 操作系统使用一个统一的**异常或中断查询程序**，按优先级顺序查询异常状态寄存器，然后转到内核处理相应程序
     - 异常大多采用软件识别
   - **硬件识别（向量中断）**
     - 异常或中断处理程序的首地址称为**中断向量**
     - 所有中断向量存放在**中断向量表**
     - 每个异常或中断被指定一个**中断类型号**，可据此快速找到对应的处理程序
     - 中断采用软件 / 硬件识别

## 5.6 指令流水线

### 5.6.1 基本概念

#### 指令流水线的定义

将指令执行过程的各阶段视为相应的**流水段**，则指令的执行过程就构成了一条指令流水线.

![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240501220002.png)

#### 提高并行性

- **时间上的并行技术**：
  - 将一个任务拆分成几个不同的**子阶段**
  - 每个阶段在**不同**的功能部件上并行执行，即**流水线技术**
- **空间上的并行技术**：
  - 在一个处理机设置多个执行相同任务的功能部件
  - 并让这些功能部件并行工作，这样的处理机称为**超标量处理机**

#### 指令集应具备的特点

- **指令长度尽量一致**，有利于简化取指和指令译码操作
- **指令格式尽量规整**，尽量保证源寄存器的位置相同，有利于在指令未知时就可取存寄存器操作数
- **采用 Load/Store 指令**，把 Load/Store 指令的地址计算和运算指令的执行步骤规整到同一个周期中，有利于减少操作步骤
- **数据和指令在存储器中“对齐”存放**，这样有利于减少访存次数使所需数据在一个流水段内就可以从存储器中找到

#### 三种基本方式

![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250824202640089.png?imageMogr2/quality/80&imageSlim)

### 5.6.2 性能指标

#### 5.6.2.1 吞吐率

单位时间内流水线所完成的任务数量，或是输出结果的数量

- 设任务数 n，处理完成 n 个任务所用的时间为 $T_k$

吞吐率：
$$TP=\frac{n}{T_k}=\frac{n}{(k+n-1)Δt}$$

- 最大吞吐率：$TP_{max}=\frac{1}{Δt}$

![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250824204806087.png?imageMogr2/quality/80&imageSlim)

- 前 $k \triangle t$ 为装入时间；前 $k \triangle t$ 为排空时间

注意：

- m 段流水线的 CPU 吞吐能力 = m 个并行部件的 CPU 吞吐能力
- m 段流水线在第 m 个时钟周期后，每个时钟周期都可完成一条指令
- m 个并行部件在 m 个时钟周期后能完成全部的 m 条指令，等价于平均每个时钟周期完成一条指令

#### 加速比

完成同样一批任务，**不使用流水线所用的时间**与**使用流水线所用的时间**之比

- 设顺序执行的时间为 $T_0$，使用流水线的执行时间 $T_k$

$$S=\frac{T_0}{T_k}=\frac{kn}{k+n-1}$$

- 最大加速比： $S_{max}=k$

#### 效率

流水线的设备利用率，在时空图上，表示为**完成 n 个任务占用的时空区有效面积**与 **n 个任务所用的时间与 k 个流水段所围成的时空区总面积**之比。（看图理解）

$$E=\frac{kn\triangle t}{kT_k}$$

![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250824205718249.png?imageMogr2/quality/80&imageSlim)

### 5.6.3 五段式

为方便流水线的设计，将每个阶段的耗时取成一样，以最长耗时为准。

流水线每一个功能段部件后面都要有一个**缓冲寄存器**，或称为**锁存器**， 其作用是保存本流水段的执行结果，提供给下一流水段使用。

运算类指令的执行过程：
![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250824213434116.png?imageMogr2/quality/80&imageSlim)

LOAD 指令：
![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250824213745337.png?imageMogr2/quality/80&imageSlim)

STORE 指令：
![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250824213941495.png?imageMogr2/quality/80&imageSlim)

通常， RISC处理器只有“取数LOAD”和“存数STORE”指令才需要**访问主存**；其他指令都是用寄存器的数据或者立即数。

条件转移指令：
![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250824214849542.png?imageMogr2/quality/80&imageSlim)

- 条件转移的写回 PC 发生在 **M 段**，不是 WB 段

无条件转移指令：
![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250824215123050.png?imageMogr2/quality/80&imageSlim)

- 写回 PC 越早越好，所以**无条件转移的写回 PC 在 EX 段**

#### 例题

![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250824215619570.png?imageMogr2/quality/80&imageSlim)

重点关注红框：

- 前一条指令必须进入译码之后，后一条才能取指令
- 不然，在指令的锁存器中，后一条指令会直接覆盖前一条指令

### 5.6.4 冒险

1. 结构冒险
   1. **资源冲突**
   2. 由于多条指令在同一时刻争用同一资源，而形成的冲突称为结构相关。
   3. 解决办法：
      1. 后一相关指令暂停一周期
      2. 资源重复配置
         1. 数据存储器＋指令存储器，也叫**指令 Cache 和 数据 Cache 分离**
2. 数据冒险
   1. 数据冲突
   2. 在一个程序中，存在必须等前一条指令执行完才能执行后一条指令的情况， 则这两条指令即数据相关。
   3. 解决办法：
      1. 把遇到数据相关的指令及其后续指令都暂停一至几个时钟周期，直到数据相关问题消失后再继续执行。
         1. 主要有 硬件阻塞（stall）和 软件插入空指令 NOP 两种方法
      2. 数据旁路
      3. 编译优化：调整指令顺序
3. 控制冒险
   1. 控制冲突
   2. 当流水线遇到转移指令和其他改变PC值的指令而造成断流时，会引起控制相关。
   3. 解决方法：
      1. 分支预测
         1. 静态预测
            1. 每次预测结果是一致的
               1. 总是预测条件不满足（not taken），可加启发式规则：在特定情况下总是预测满足（taken）
         2. 动态预测
            1. 根据程序执行的历史情况，进行动态预测调整，能达90%的预测准确率，成功率高
      2. 预取两个方向的指令
      3. 加快和提前形成条件码
      4. 提高转移方向的猜准率

### 5.6.5 分类

- 不考，动态流水线可以看一下

![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250824212315925.png?imageMogr2/quality/80&imageSlim)

![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250824212425763.png?imageMogr2/quality/80&imageSlim)

### 5.6.6 高级流水线

#### 5.6.6.1 超标量

每个时钟周期内可**并发多条独立指令**，以并行操作方式将两条或多条指令编译并执行，也称**动态多发射技术**（动态调度技术）。

![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240502160930.png)

- 每个时钟周期内可**并发多条独立指令**
  - 并不影响流水线功能段的处理时间
- 要配置**多个功能部件**，实际上是以**空间换时间**
- **乱序执行**
- 不能调整指令顺序，通过编译优化技术，把可并行执行的指令搭配起来

之前介绍的普通流水线是常规标量的单流水线。

#### 超长指令字

由编译程序挖掘出**指令潜在的并行性**，将多条能并行操作的指令组合成一条具有**多个操作码**的超长指令字（可达几百位），也称**静态多发射技术**。
![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240502161143.png)

- 需要**多个处理部件**

#### 超流水线

- 时分复用思路

在一个时钟周期内再分段，在一个时钟周期内一个功能部伴使用多次。

![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240502161507.png)

- 流水线功能段越多，时钟周期越短，**指令吞吐率越高**
- 通过**提高流水线主频**的方式来提升流水线性能的
- 流水线级数越多，用于**流水线寄存器的开销越大**
- 不能调整指令顺序，依靠编译优化

## 5.7 多处理器

### 5.7.1 基本概念

- 基于**指令流**的数量和**数据流**的数量，将计算机体系结构分为 SISD，SIMD，MISD 和 MIMD
- 常规的单处理机属于 SSID，常规的多处理机属于 MIMD

### 5.7.2 SISD

- 单指令流单数据流结构
  - 单指令流：指令序列**只能并发，不能并行**
  - 单数据流：一个指令一次只处理一个数据流（一个 / 对数据）
  - 408计组使用的就是 SISD
- **串行**计算机结构
- 通常**只包含一个处理器和一个存储器**
- 有些使用流水线的方式，所以有时会设置多个功能部件，并采用**多模块交叉**方式组织存储器

### 5.7.3 SIMD

- 单指令流多数据流结构
- **数据级并行技术**
  - 一个指令流同时对多个数据流进行处理
- 由**一个指令控制部件、多个处理单元组成**
  - 每个处理单元虽然执行的都是同一条指令, 但每个单元都**有自己的地址寄存器**（局部存储器），就有了不同的数据地址
- 一个顺序应用程序被编译之后, 可能按照 SISD 组织并运行于串行硬件上，也可能按 SIMD 组织并运行于并行硬件上
- **for 循环效率高**，但 switch 或 case 时效率低

![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250826161032080.png?imageMogr2/quality/80&imageSlim)

**向量处理器**也是 SIMD 的变体，是一种实现了直接操作一维数组（向量）指令集的 CPU。

![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250826161509275.png?imageMogr2/quality/80&imageSlim)

### 5.7.4 MISD

- 多指令流单数据流结构
  - 多指令流：指令序列**并行**
- 同时执行多条指令，处理同一个数据
- 实际上**不存在**这样的计算机

### 5.7.5 MIMD

- 多指令流多数据流结构
  - 现代计算机就是 MIMD
- **线程级并行**、甚至是线程级以上并行技术
- 同时执行多条指令，处理多个不同的数据

MIMD 分为多计算机系统和多处理器系统：

- **多计算机系统**
  - 分布式计算机系统
  - 每个计算机节点都具有各自的**私有存储器**，并且具有独立的主存地址空间
  - 不能通过存取指令来访问不同节点的私有存储器
  - 而要通过消息传递进行数据传送，也称为**消息传递 MIMD**
    ![300](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250826160958268.png?imageMogr2/quality/80&imageSlim)
- **多处理器系统**
  - **共享存储**多处理器（SMP）系统的简称
  - 它具有**共享的单一地址空间**，通过访存指令来访问系统中的所有存储器，也称**共享存储 MIMD**

### 5.7.6 多核处理器

- 将**多个处理单元**集成到单个 CPU 中，每个处理单元称为一个**核（core）**
- 每个核可以**有自己的 Cache，也可以共享一个 Cache**
- 所有核一般都是**对称**的，并且共享主存，因此多核属于**共享存储**的对称多处理器
  - 2.4GHz 的双核，两个核都是 2.4GHz
- 在多核计算机系统中，若要充分发挥硬件的性能，必须采用**多线程执行**，使每个核在**同一时刻都有线程在执行**，这是真正的并行执行

## 5.8 硬件多线程

- 引入硬件多线程的**目的**：为了减少开销
- 硬件多线程中必须为**每个线程提供单独的通用寄存器组、单独的程序计数器**等
- 线程的激活只**需要激活选中的寄存器**，从而省略了与存储器数据交换的环节，节省了开销

![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240502171452.png)

![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240502171515.png)

### 5.8.1 细粒度多线程

- 多个线程之间**轮流交叉执行指令**，多个线程之间的指令是互不相关的
- 可以乱序并行执行
- 该方式下，处理器能在**每个时钟周期**切换线程
- 指令级并行，线程间不并行

### 5.8.2 粗粒度多线程

- **连续几个时钟周期**都执行**同一线程**的指令序列
- 仅在**一个线程出现较大开销的阻塞**（流水线阻塞）时，才切换线程
  - 如 Cache 缺失
- 当发生流水线阻塞的时候，必须清除被阻塞的流水线
- 新线程的指令开始执行前需要重载流水线，**开销较上一种较大**
- 指令级并行，线程间不并行

### 5.8.3 同时多线程（SMT）

- 又叫做**超线程技术** HT
- 一个 CPU 提供两套线程处理单元
- 性能不等于两个 CPU，模拟实体双核，双核也不是独立资源
- 一个时钟周期内，同时发射**多个线程**的指令
- **指令级并行，线程级并行**

# 6 总线

## 6.1 概述

总线的物理实现：
![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250827203800217.png?imageMogr2/quality/80&imageSlim)

总线是一组能够为多个部件**分时**和**共享**的公共信息传送线路。

- I/O 设备的种类和数量越来越多，设计总线来解决 I/O 设备与主机之间连接的灵活性
- 优点：便于增减外设，减少信息传输线的条数
- **缺点**：降低了信息传输的并行性和信息的传输速度

两大特点：

- **分时性**
  - 同一时刻只允许有**一个**部件向总线**发送**消息，如果系统中有多个部件，则它们只能分时地向总线发送消息
- **共享性**
  - 总线上可以挂接多个部件，**多个**部件可同时从总线上**接收**相同的信息

按其**对总线有无控制能力**可分为主设备和从设备：

- 主设备：获得总线控制权的设备
- 从设备：被主设备访问的设备，它只能响应从主设备发来的各种总线命令

总线的其他特性：

- 机械特性：尺寸，形状
- 电气特性：传输方向和有效电平范围
- 功能特性：每根传输线的功能
- 时间特性：信号和时序的关系

## 6.2 分类

### 6.2.1 按数据传输方式

- **串行传输**
  - 只有一条双向传输 / **两条单向**传输的数据线，数据按**比特**串行传输
  - 优点
    - 成本低廉，广泛应用于**长距离传输**
    - 应用于计算机内部时，可以节省布线空间
    - 可通过不断提高工作频率来提高传输速度，使其**速度最终超越并行总线**
  - 缺点
    - 在数据发送和接收的时候要进行拆卸和装配，要考虑串行-并行转换的问题
- **并行传输**
  - 有**多条**双向传输的数据线，可以实现**多比特位**的同时传输
  - 优点
    - 总线的**逻辑时序比较简单**，电路实现起来比较容易
  - 缺点
    - 信号线数量多，占用更多的布线空间
    - 数据线之间相互干扰会造成传输错误，因此适合**近距离传输**
- **总线复用方式**：不同信号在同一条信号线上分时传输

### 6.2.2 按功能

- **片内总线**
  - CPU 芯片**内部**寄存器与寄存器之间、寄存器与 ALU 之间的总线
- **系统总线**
  - 各功能部件（CPU、主存、I/O 接口）**之间**相互连接的总线
  - 按系统总线**传输内容**的不同又可分为 3 类
    - **数据总线**
      - 传输各功能部件之间的数据信息
      - 是**双向**传输线
      - 位数反映一次能传送的数据的位数
        - 与机器字长、存储字长有关
      - 区分：数据**通路**表示的是数据流经的路径；数据**总线**是承载的媒介
    - **地址总线**
      - 指出主存和 I/O 设备接口电路的地址
      - 是**单向**传输线
      - 位数反映最大的寻址空间
        - 与主存地址空间大小及设备数量有关
    - **控制总线**
      - 一根控制线传输一个信号
      - 有出：CPU 送出的控制命令
      - 有入：主存（或外设）返回 CPU 的控制信号
- **通信总线**
  - 也称**外部总线**
  - 计算机系统之间或计算机系统与其他系统（如远程通信服务、测试设备）之间传送信息的总线
- **I/O 总线**
  - 主要用于连接中低速的 I/O 设备
  - 通过 I/O 接口与系统总线相连接
  - 目的是**将低速设备和高速总线分离**，以提升总线的系统性能
  - 常见的有 USB、PCI 总线

### 6.2.3 按时序控制

- 同步总线
  - 总线上连接的部件或设备通过**统一的时钟**进行同步
- 异步总线
  - 以**信号握手**的方式来协调各部件或设备之间的信息传输，总线操作时序**不固定**

## 6.3 系统总线的结构

#### 6.3.1.1 单总线结构

CPU、主存、I/O 设备（通过 I/O 接口）都连接在一组**系统总线**上，允许 I/O 设备之间、I/O 设备和 CPU 之间或 I/O 设备与主存之间直接交换信息。

![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240503164829.png)

- **优点**：结构简单，成本低，易于接入新的设备
- **缺点**：带宽低，负载重，多个部件只能征用唯一的总线，且不支持并发传送操作

#### 双总线结构

双总线结构有两条总线：

- **主存总线**
  - 用于 CPU、主存和通道之间进行数据传送
- **I/O 总线**
  - 用于多个外部设备与通道之间进行数据传送
  - 主存总线和IO总线通过**通道**连接

![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250828205548124.png?imageMogr2/quality/80&imageSlim)

- 通道
  - 具有特殊功能的处理器， 能对IO设备进行统一管理
  - 将较低速的 I/O 设备从单总线上分离出来，实现**存储器总线和 I/O 总线分离**
- 突发（猝发）传送
  - 送出一个地址，收到多个地址连续的数据
  - 一次总线事务中，主设备**只需给出一个首地址**，就可以从首地址开始的若干连续单元读出或写入多个数据
- **缺点**：需要增加**通道**等硬件设备

#### 三总线结构

三总线结构：

- 主存总线
- I/O 总线
- DMA 总线（直接内存访问）

![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250828205823790.png?imageMogr2/quality/80&imageSlim)

- **优点**：提高了 I/O 设备的性能，使其更快地响应命令，提高系统吞吐量
  - DMA 使得高速外设不用走速度慢的IO总线
- **缺点**：系统工作效率较低

#### 四总线结构

桥接器：用于连接不同的总线，具有数据缓冲、转换和控制功能。

![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250828210059780.png?imageMogr2/quality/80&imageSlim)

### 6.3.2 性能指标

- **总线传输周期**
  - **总线周期**
  - **一次总线操作所需的时间**，由若干总线时钟周期构成
  - 包括申请阶段、寻址阶段、传输阶段和结束阶段
- **总线时钟周期**
  - 机器的时钟周期
  - 计算机有一个统一的时钟，以控制整个计算机的各个部件，总线也要受此时钟的控制
  - 现在的计算机中，总线时钟周期也有可能由桥接器提供
  - 总线周期和时钟周期的关系是不确定的，按题目来
- **总线时钟频率**
  - 机器的时钟频率，为时钟周期的倒数
  - $时钟频率=\frac{1}{时钟周期}$
- **总线工作频率**
  - 总线上各种操作的频率，为**总线周期的倒数**
  - $工作频率=\frac{1}{总线周期}$
  - 若总线周期 = N 个时钟周期，则总线的 $工作频率=\frac{时钟频率}{N}$
  - 实际上指**一秒内传送几次数据**
    - e.g. 若一个时钟周期传两次数据，则工作频率是时钟频率的两倍
- **总线宽度**
  - 总线位宽
  - 总线上**同时能传输的数据位数**
  - 通常指**数据总线的根数**，如 32 根称为 32 位（bit）总线
- **总线带宽**
  - 总线的最大**数据传输率**，即**单位时间内总线上最多可传输数据的位数**
  - $总线带宽=工作频率×总线位宽(bit/s)=工作频率×\frac{总线位宽}{8}（B/s）$
  - $总线带宽=\frac{总线宽度}{总线周期}（bit/s）=\frac{总线宽度/8}{总线周期}（B/s）$
  - 在计算实际的**有效数据传输率**时，要用实际传输的数据量除以耗时
- **总线复用**
  - 一种信号线在不同的时间传输不同的信息
  - 可以使用较少的线传输更多的信息，从而节约空间和成本
- **信号线数**
  - 地址总线、数据总线和控制总线3种总线数的**总和**称为信号线数

### 6.3.3 常见的总线标准

- 不考

总线标准是国际上公布的互连各个模块的标准，是把各种不同的模块组成计算机系统时必须遵守的规范。

- PCI，EISA，ISA是并行总线
- USB，PCI-Expressx16是串行总线
- 高速设备采用局部总线连接，可以节省系统的总带宽

常见 12 种标准：

1. ISA：
   - 工业标准体系结构
   - 非局部总线
   - 最早出现的微型计算机的系统总线，应用在IBM的AT机上
2. EISA：扩展的ISA
3. VESA：视频电子标准协会
4. PCI：
   - 外部设备互连
   - 支持即插即用，局部总线
5. AGP：加速图形接口，一种视频接口标准
6. PCI-E：最新的总线接口标准，它将全面取代线性的PCI和AGP
7. RS-232C：
   - 由美国电子工业协会推荐的一种串行通信总线
   - 适用于串行二进制交换的数据终端设备和数据通信设备之间的标准接口
8. USB：
   - 通用串行总线
   - 即插即用，热插拔，有很强的连接能力，有很好的可扩展性；高速传输
9. PCMCIA：
   - 广泛应用于笔记本电脑的一种接口标准
   - 是一个用于扩展功能的小型插槽。即插即用
10. IDE：
    - 集成设备电路
    - 更准确地称为ATA，硬盘和光驱通过IDE接口与主板连接
11. SCSI：
    - 小型计算机系统接口
    - 是一种用于计算机和智能设备之间（硬盘、软驱）系统级接口的独立处理器标准
12. SATA：
    - 串行高级技术附件
    - 是一种基于行业标准的串行硬件驱动器接口

## 6.4 事务和定时

### 6.4.1 总线事务

从请求总线到完成总线使用的操作序列，即在一个总线周期中发生的一系列活动。

总线周期的四个阶段：

- 申请阶段
  - 传输请求
    - 主设备（CPU 或 DMA）发出总线传输请求，并且获得**总线控制权**
  - 总线仲裁
    - 总线仲裁机构决定将下一个传输周期的总线使用权授予某个申请者
- 寻址阶段
  - 主设备通过总线给出要访问的从设备地址及有关命令，启动从模块
- 传输阶段
  - 主模块和从模块进行数据交换，可单向或双向进行数据传送（一般只能传输一个字长的数据）
- 结束 / 释放阶段
  - 主模块的有关信息均从系统总线上撤除，让出总线使用权

总线上的数据传送方式：

- **非突发式**
  - 在每个传送周期内都**先传送地址，再传送数据**
  - 主、从设备之间通常**每次只能传输一个字长**的数据
- **突发（猝发）式**
  - 发送方在传输完成地址后，连续进行若干次数据的发送，即一**次传输一个地址和一批连续的数据**
  - 能够进行**连续成组数据**的传送；其寻址阶段发送的是连续数据单元的首地址
  - 可以提高总线数据传输率
  - 主设备只需给出一个首地址，从设备就能从首地址开始的若干连续单元读出或写入多个数据

### 6.4.2 总线定时

总线在双方交换数据的过程中需要时间上配合关系的控制，实质是一种协议或者规则。

#### 同步定时方式

- 由**统一时序控制**的通信方式
- 同步通信采用**公共时钟**，有统一的时钟周期，同步时钟信号**不由**各设备提供
- 同步控制既可以**用于 CPU 控制**，又可用于**高速的外部设备控制**
  ![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240503181107.png)

优点：

- 传送速度快，具有较高的传输速率
- 总线控制逻辑简单
- 同步通信**不需要应答信息且总线长度短**
- 同步通信用一个公共的时钟信号进行同步
- 同步通信中，**各部件的存取时间较接近**

缺点：

- 主从设备属于**强制性同步**
- 不能及时进行数据通信的有效性验证
- 可靠性较**差**

##### 适用场景

- 适用于**总线长度较短**及**总线所接部件的存储时间比较接近**的系统
- 采用同步控制也可以进行数据的传输，但不能发挥快速设备的高速性能

#### 异步定时方式

- 没有统一的时钟；没有固定的时间间隔；不采用时钟信号，只采用握手
- 完全依靠**传送双方相互制约的“握手”信号**来实现定时控制
- 传送操作是由双方按需求分配时间的
- 每次握手完成一次通信，但是一次通信往往交换多位数据

优点：

- 总线周期长度可变
- 能保证两个工作速度相差很大的部件或设备之间可靠地进行信息交换
- 自动适应时间的配合

缺点：

- 比同步稍复杂一些，速度比同步方式慢

##### 适用场景

- 主要用于在不同的设备间进行通信

##### 分类

- **不互锁方式**
  - 主设备发出“请求”信号后，不必等到接到从设备的“回答”信号，而是经过一段时间，便撤销“请求”信号
  - 从设备在接到“请求”信号后，发出“回答”信号，并经过一段时间，自动撤销“回答”信号。双方不存在互锁关系
  - **速度最快，可靠性最差**
- **半互锁方式**
  - 主设备发出“请求”信号后，必须待接到从设备的“回答”信号后，才撤销“请求”信号，有互锁的关系
  - 从设备在接到“请求”信号后，发出“回答”信号，但不必等待获知主设备的“请求”信号已经撤销，而是隔一段时间后自动撤销“回答”信号，不存在互锁关系
- **全互锁方式**
  - 主设备发出“请求”信号后，必须待从设备“回答”后，才撤销“请求”信号
  - 从设备发出“回答”信号，必须待获知主设备“请求”信号已撤销后，再撤销其“回答”信号。双方存在互锁关系
  - **最可靠，速度最慢**

![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240503180936.png)

#### 半同步定时方式

统一时钟的基础上，增加一个 **“等待”响应信号** WAIT

- **同步**：
  - **发送方**用**系统时钟前沿**发信号
  - **接收方**用**系统时钟后沿**判断、识别
- **异步**：允许不同速度的模块和谐工作
  ![image.png](https://qingwu-oss.oss-cn-heyuan.aliyuncs.com/lian/img/20240503182027.png)

优点：

- 控制方式比异步定时简单
- 各模块在系统时钟的控制下同步工作，可靠性较高

缺点：

- 系统的时钟频率不能要求太高
- 整体上看，系统工作的速度不是很高

#### 分离式定时方式

之前三种通信方式的共同点：

- 主模块发地址、命令（总线被使用）
- 从模块准备数据（**总线空闲**）
- 从模块向主模块发数据（总线被使用）

简单来说，分离式就是为了充分利用中间总线空闲的时间。

分离式将总线事务分解为请求和应答两个子过程：

- 子周期 1：**主模块**申请**占用总线**，使用完后**放弃总线**的使用权
- 子周期 2：**从模块**申请**占用总线**，将各种信息送至总线上

各模块均有权申请占用总线

- 采用同步方式通信，不等对方回答
- 各模块准备数据时，不占用总线
- 总线利用率提高

优点：

- 在不传送数据是释放总线，使总线可接受其他设备的请求，不存在空闲等待时间

缺点：

- 控制复杂，开销较大

# 7 IO系统

IO系统的基本组成：
![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250830163638778.png?imageMogr2/quality/80&imageSlim)

## 7.1 IO接口

IO接口就是 IO控制器。

可分为：

- 并行接口、串行接口
- 程序查询接口、中断接口、DMA接口
- 可编程接口、不可编程接口

### 7.1.1 控制方式

- 大概率不考

![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250830155148407.png?imageMogr2/quality/80&imageSlim)

程序查询、程序中断：
![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250830161607153.png?imageMogr2/quality/80&imageSlim)

但是对于高速IO设备，比如磁盘，假如每准备好一个字就向 CPU 发出中断请求，则 CPU 会浪费很多时间在处理中断程序，利用率下降。

可以采用 DMA 的方式处理高速IO设备：
![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250830162015464.png?imageMogr2/quality/80&imageSlim)

另外，对于有大量IO设备的场景，只依靠 CPU 处理IO是不够的，需要引入通道控制方式，通道可以理解为是一个只有部分功能的弱 CPU。

![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250830163458929.png?imageMogr2/quality/80&imageSlim)

### 7.1.2 功能

IO接口的功能：

- **进行地址译码和设备选择**
  - 使主机和指定外设交换信息
- **实现主机和外设的通信联络控制**
  - 实现主机—I/O 接口—I/O 设备之间的通信
- **实现数据缓冲**
  - 通过数据缓冲寄存器（DBR）达到主机和外设工作速度的匹配
- **信号格式的转换**
  - 串-并、并-串、电平、数-模、模-数等格式转换
  - 因为存在外部设备串行输入，而IO接口需要向 CPU 并行发送数据的情况
- **传送控制命令和状态信息**
  - 接收从控制总线发来的控制信号、时钟信号
  - 通过状态寄存器反馈设备的各种错误、状态信息，供 CPU 查用

![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250830164326317.png?imageMogr2/quality/80&imageSlim)

- **外部接口**：通过接口电缆与外设连接，数据传输可能是串行方式，因此 I/O 接口需具有串/并转换功能
- **内部接口**与系统总线相连，实质上是与内存、CPU 相连

### 7.1.3 基本结构

![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250830165034350.png?imageMogr2/quality/80&imageSlim)

主机与外设之间的连接通路：

- 主机/内存 --- 系统总线（IO总线） --- IO接口 --- 通信总线（接口电缆） --- 外设

接口内的寄存器：

- 数据缓冲寄存器
- 状态寄存器
- 控制寄存器

主机侧：

- 数据线
  - 读写数据、状态字、控制字、**中断类型号**
    - 2012真题
- 地址线
  - 端口地址
- 控制线
  - 读写信号、中断信号

如何确定要操作的设备：每个设备对应一组寄存器，操作不同的寄存器就是在操作不同的设备

补充：I/O 指令

- 对数据缓冲寄存器、状态/控制寄存器的进行访问操作的指令
- 只能在 OS 内核的底层 I/O 软件中使用
- I/O 指令实现的数据传送通常发生在**通用寄存器和 IO 端口**之间
  - 2017真题
- 是一种特权指令，是机器指令的一类，是系统指令的一部分
  - 与通用指令格式不同

### 7.1.4 IO端口及其编址

IO端口：IO控制器中的各种寄存器

- 接口 = 端口 + 相应的控制逻辑
- IO接口中，CPU 可访问的寄存器称为 IO端口
  - 2014真题

主要的 I/O 端口有：

- 数据端口：CPU 对数据端口中的数据执行**读写**操作
- 状态端口：对状态端口中的外设状态只能执行**读**操作
- 控制端口：对控制端口中的各种控制命令只能执行**写**操作

两种编址方式：
![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250830165558333.png?imageMogr2/quality/80&imageSlim)

#### 统一编址

- 存储器映射方式
- 把 I/O 端口当做**存储器的单元进行地址分配**
- CPU **不需要设置专门的 I/O 指令**，用**统一的访存指令**就可以访问 I/O 端口
- 依靠**地址码**的不同区分存储单元和 I/O 设备
- RISC 常用

- **优点**：
  - 不需要专门的 I/O 指令
  - 可以使 CPU 访问 I/O 的操作更灵活、更方便
  - 可以**使端口有较大的编址空间**
- **缺点**：
  - 端口占用主存地址空间，使**内存容量变小**
  - **外设寻址时间长**（地址位数多，地址译码速度慢）
  - 译码电路复杂，**降低了译码速度**
    - 在识别 I/O 端口时全部地址线都需要参加译码

#### 独立编址

- I/O 映射方式
- I/O 端口的地址空间与主存地址空间是**两个独立的地址空间**
- 需要设置**专门的 I/O 指令来访存 I/O 端口**
- 通过专门的 I/O **指令**来区分存储单元和 I/O 设备
- I/O 指令的地址码给出 I/O 端口号
- INTEL 常用

- **优点**：
  - 使用专用 I/O 指令，比如 IN、OUT，**程序编制清晰**
  - I/O 端口地址位数少，译码简单，**地址译码速度快**
- **缺点**：
  - I/O 指令少，一般**只能对端口进行传送操作**
  - 需要 CPU 提供存储器读/写、I/O 设备读/写两组控制信号，增加了控制逻辑电路的**复杂性**

## 7.2 IO方式

### 7.2.1 程序查询方式

![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250830180515392.png?imageMogr2/quality/80&imageSlim)

- 主要特点
  - CPU **有“踏步”等待现象**
  - CPU 与 I/O **串行工作**
- **优点**
  - 接口设计简单，设备量少
- **缺点**
  - CPU 在信息传送过程中要花费很多时间来查询和等待
  - 在一段时间内只能和一台外设交换信息，效率大大降低
- **独占查询**
  - 一旦设备被启动，CPU 就一直持续查询接口状态，CPU 花费 100% 的时间用于 I/O 操作，此时外设和 CPU 完全串行工作
- **定时查询**
  - CPU 周期第查询接口状态，每次总是等到条件满足才进行一个数据的传送，传送完成后返回到用户程序
  - 时间间隔与设备的数据传输速率有关

### 7.2.2 程序中断方式

#### 中断技术简介

在计算机执行现行程序的过程中，出现某些急需处理的异常情况或特殊情求 CPU 暂停中止现行程序而转去对这些异常情况或特殊请求进行处理，处理完毕后再返回到现行程序的断点处，继续执行原程序。

- 早期的中断技术就是**为了处理数据传送**
- 中断响应阶段 CPU 进行的操作
  - 关中断
  - 保护断点和程序状态
  - 识别中断源
- 多重中断系统在保护被中断进程现场时关中断，执行中断程序时开中断
- CPU 一般在一条指令执行结束的阶段采样中断请求信号，查看是否存在中断请求，然后决定是否响应中断
- 中断隐指令的工作
  - 关中断
  - 保存断点
  - 引出中断服务程序
- 通用计算器的保护由中断服务程序完成
- 中断优先级由**屏蔽字**决定，而**不是**根据请求的先后次序
- 有中断请求时，如果是关中断的姿态，或新中断请求的优先级较低，则不能响应新的中断请求

主要功能：

- 实现 CPU 和 I/O 设备的**并行工作**
- **处理硬件故障和软件错误**
- 实现人机交互，用户干预机器需要用到中断系统
- 实现多道程序、分时操作，多道程序的切换需要借助于中断系统
- 实时处理需要借助中断系统来实现快速相应
- 实现应用程序和操作系统（管态程序）的切换，称为**软中断**
- 多处理器系统中各处理器之间的信息交流和任务切换

主要思想：

- CPU 在程序中安排好在某个时机启动某台外设
- 然后 CPU 继续执行当前的程序，不需要像查询方式那样等待外设准备就绪
- 一旦外设完成数据传送的准备工作，就主动向 CPU 发出中断请求，请求 CPU 为自己服务
- 在可以响应中断的条件下，CPU 暂时中止正在执行的程序，转去执行中断服务程序为外设服务，在中断服务程序中完成一次主机与外设之间的数据传送，传送完成后，CPU 回到原来的程序

#### 中断请求

CPU响应中断必须满足以下3个条件：

1. 中断源有中断请求
2. CPU允许中断，即开中断
3. 一条指令执行完毕，且没有更紧迫的任务

**中断源**是请求 CPU 中断的设备或事件，一台计算机允许有多个。

为了记录中断时间并区分中断源，中断系统对每个中断源设置**中断请求标记触发器INTR**。

- 1 表示有请求

这些触发器组成**中断请求标记寄存器**：
![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250830183542662.png?imageMogr2/quality/80&imageSlim)

- 该寄存器可集中在 CPU 中，也可分散在各个中断源中

另外，

- **可屏蔽中断**：**INTR** 线发出，关中断模式下不被响应
  - 在IO系统这一章，基本只讨论可屏蔽中断
- **不可屏蔽中断**：NMI 线发出，如时钟中断、电源掉电

##### 中断判优

中断判优可以通过硬件 / 软件实现：

- 软件：通过查询程序实现
  - 比硬件慢，不常用
  - ![300](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250830183820752.png?imageMogr2/quality/80&imageSlim)
- 硬件：通过**硬件排队器**实现
  - ![300](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250830183656811.png?imageMogr2/quality/80&imageSlim)

优先级设置：

- 不可屏蔽中断 > 内部异常 > 可屏蔽中断
- 硬件故障 > 软件中断
- DMA 中断请求 > I/O 设备传送的中断请求
- 高速设备 > 低速设备
- 输入设备 > 输出设备
- 实时设备 > 普通设备

**注意**：

- 中断优先级包括**响应**优先级和**处理**优先级
- 响应优先级由硬件线路或查询程序的查询顺序决定，不可动态改变
- 处理优先级可有中断屏蔽技术动态调整，以实现多重中断

#### 中断响应

- 2016大题

中断响应阶段，CPU执行中断隐指令。

**中断隐指令**：硬件的**一系列**自动操作，用于执行中断服务程序（并不是指令系统中的一条真正的指令）

- 关中断
  - 在保护程序的断点和现场信息过程中，不能响应更高级中断源的中断请求
- 保存断点
  - 将原程序的断点保存在栈或特定寄存器中
  - 中断的断点是**下一条**指令的地址
- 引出中断服务程序
  - 识别中断源，将对应的服务程序入口地址送入 PC
  - 如何找到入口地址见下一节

##### 中断识别

中断识别分为：

1. **向量中断** / 硬件向量法
2. **非向量中断** / 软件查询法

硬件向量法：
CPU 响应中断后，通过识别**中断源**获得**中断类型号**（也叫向量地址），然后据此计算出对应**中断向量的地址**；再根据该地址从**中断向量表**中取出**中断服务程序**的**入口地址**，并送入 PC，以转而执行中断服务程序。

![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250830194844737.png?imageMogr2/quality/80&imageSlim)

- 每个中断源有一个唯一的类型号
  - 每个中断类型号对应一个中断服务程序
  - 类型号也叫向量地址，作用就是找到向量的地址
- **中断向量**
  - 中断服务程序的入口地址
- **中断向量表**

  - 存储系统中的全部中断向量

- **注意**：
  - 中断请求和响应信号是在 I/O 总线的**控制线**上传送
  - CPU 响应某一中断后，就从**数据线**上获取该中断源的中断类型号，并计算对应中断向量在中断向量表中的位置

#### 中断服务程序

中断服务程序的主要任务：

1. 保护现场
   1. **保存通用寄存器和状态寄存器**的内容，以便返回原程序后可以恢复CPU环境。可使用堆栈，也可以使用特定存储单元。
      1. eg：保存ACC寄存器的值
2. 中断服务（设备服务）
   1. 主体部分，如通过程序控制需打印的字符代码送入打印机的缓冲存储器中
      1. eg：中断服务的过程中有可能修改ACC寄存器的值
3. 恢复现场
   1. 通过出栈指令或取数指令把之前保存的信息送回寄存器中
      1. eg：把原程序算到一般的ACC值恢复原样
4. 中断返回
   1. 通过**中断返回指令**回到原程序断点处。

#### 整个中断处理过程

中断处理过程分为：

1. 执行中断隐指令（中断响应）
2. 中断服务程序

![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250830200252944.png?imageMogr2/quality/80&imageSlim)

#### 多重中断

- 单重中断：若CPU在执行中断服务程序的过程中，又出现了新的更高优先级的中断请求，而**CPU对新的中断请求不予响应**
- **多重中断**（中断嵌套）：若 CPU 在执行中断服务程序的过程中，又出现了**新的、更高优先级**的中断请求，CPU 暂停现行的中断服务程序，转去处理新的中断请求

CPU 支持多重中断的条件：

1. 在中断服务程序中提前设置**开中断**指令
2. 优先级别高的中断源 有权中断 优先级别低的中断源

多重中断需要应用**中断屏蔽技术**：

- 每个中断源都有一个**屏蔽触发器**（MASK）
  - 1 表示**屏蔽**该中断源的请求，0 表示可以正常请求
- 所用 MASK 组合在一起便构成一个**屏蔽字寄存器**，寄存器的内容称为**屏蔽字**
- 屏蔽字中 1 越多，优先级越高
- 每个屏蔽字中至少有一个 1
  - 至少能屏蔽自身的中断

需要改造之前的硬件排队器，加上 MASK：
![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250830223157829.png?imageMogr2/quality/80&imageSlim)

e.g. 求屏蔽字
![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250830223405928.png?imageMogr2/quality/80&imageSlim)

e.g. 求执行轨迹
![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250830223531377.png?imageMogr2/quality/80&imageSlim)

#### 程序中断总结

![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250830224132155.png?imageMogr2/quality/80&imageSlim)

### 7.2.3 DMA 方式

- Direct Memory Access 直接存储器存取
- 一种**完全**由硬件进行成组信息传送的控制方式

DMA 在数据准备阶段，**CPU与外设并行工作**，在外设与内存之间开辟一条**直接数据通路**，信息传送不再经过 CPU。

- 不需要保护、恢复CPU现场等操作，**降低**了CPU在传送数据时的开销
- 适用于磁盘、显卡、声卡、网卡等**高速设备**大批量数据的传送
- 硬件开销大

DMA 方式中，**中断**的作用仅限于故障和正常传送结束

#### DMA 控制器

- **DMAC**，又叫 DMA 控制器（DMA 接口），是**对数据传送过程进行控制的硬件**

![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250830235427466.png?imageMogr2/quality/80&imageSlim)

- 单总线结构

在 DMA 过程中，DMAC 将接管 CPU 的地址总线、数据总线和控制总线，CPU 的主存控制信号被禁用

DMAC 的组成：

- **主存地址计数器**：存放要交换数据的主存地址
- **传送长度计数器**：记录传送数据的长度（总字数）。每传送一个字，计数器就减 1，直至计数器为 0，表示该批数据传送完毕
- **数据缓冲寄存器**：暂存每次传送的数据【DMA 接口与主存之间的传送单位为字，DMA 与设备之间的传送单位可能为字节或位】
- **DMA 请求触发器**：每当 I/O 设备准备好数据后，给出一个控制信号，使 DMA 请求触发器置位
- **“控制/状态”逻辑**：由控制和时序电路及状态标志组成，用于指定传送方向，修改传送参数，并对 DMA 请求信号、CPU 响应信号进行协调和同步
- **中断机构**：当一个数据块传送完毕后触发中断机构，向 CPU 提出中断请求

DMA 过程：

1. 接收外设发出的 DMA 请求，并向 CPU 发出总线请求
2. CPU 响应此总线请求，发出总线响应信号，接管总线控制权，进入 DMA 操作周期
3. 确定传送数据的主存单元地址及长度，并自动修改主存地址计数和传送长度计数
4. 规定数据在主存和外设间的传送方向，发出读写等控制信号，执行数据传送操作
5. 向 CPU 报告 DMA 操作结束

#### 7.2.4 DMA 方式

**前文讲 DMAC 时，使用的是单总线的图，但是 DMA 方式一般是指三总线的结构。**

![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250831000317623.png?imageMogr2/quality/80&imageSlim)

在外设与主存之间开辟一条**直接数据通路**，DMA总线。

DMA 方式的特点：

- 主存**既可以被 CPU 访问，也可被外设访问**
- 在数据块传送时，主存地址的确定、传送数据等都由**硬件直接实现**
- 主存中要开辟**专用缓冲区**，及时供给和接收外设的数据
- DMA 传送速度快，**CPU 和外设并行**工作，提高了系统效率
- DMA 在传送**开始前**要通过程序进行预处理，**结束后**要通过中断方式进行后处理

在**三总线**结构中，IO设备和 CPU 同时访问主存时，可能发生冲突。

故，DMAC 与 CPU 采用以下三种方式访问主存：

1. 停止 CPU 访问
   - 当 I/O 设备有 DMA 请求时，由 **DMA 接口向 CPU 发送一个停止信号**，使 CPU 放弃总线控制权，停止访问主存，直到 DMA 传送一块数据结束
   - **优点**：控制简单，适用于数据传输速率很高的 I/O 设备实现成组数据的传送
   - **缺点**：DMA 访问主存时，CPU 基本上处于不工作状态
2. DMA 与 CPU 交替访问
   - 将 CPU 的工作周期分成**两个时间片**，一个给 CPU 访存，另一个给 DMA 访存，这样在每个周期内，CPU 和 DMA 就都可以轮流访存
   - 总线使用权**分时控制**
   - **优点**：不需要申请、建立和归还总线控制权，具有很高的传送速率
   - **缺点**：相应的硬件逻辑变得更复杂
3. 周期挪用（周期窃取）
   - 规定 **IO 访存的优先级高于 CPU 访存**，IO设备需要访存时，直接挪用一个存取周期，传送完一个数据字后立即释放总线（单字传送方式）
   - I/O 设备有 DMA 请求时，会遇到 3 种情况：
     1. 此时 CPU 不访存
     2. CPU 正在访存，待存取周期结束后，CPU 再将总线占有权**让出**
     3. I/O 和 CPU 同时请求访存，CPU 要暂时放弃总线占有权
   - **优点**：既实现了 I/O 传送，又较好地发挥了主存与 CPU 的效率
   - **缺点**：每挪用一个主存周期，DMA 接口都要申请、建立和归还总线控制权

#### DMA 与 中断 对比

![](https://bu44er-1313346488.cos.ap-shanghai.myqcloud.com/obsidian/20250831001512564.png?imageMogr2/quality/80&imageSlim)

# 8 考纲

**考察目标**

1. 理解单处理器计算机系统中主要部件的工作原理、组成结构以及相互连接方式。
2. 掌握指令集体系结构的基本知识和基本实现方法，对计算机硬件相关问题进行分析，并能够对相关部件进行设计。
3. 理解计算机系统的整机概念，能够综合运用计算机组成的基本原理和基本方法，对高级编程语言（C语言）程序中的相关问题进行分析，具备软硬件协同分析和设计能力。

**考察内容**

**第一章 计算机系统概述**

(一) 计算机系统层次结构

1. 计算机系统的基本组成
2. 计算机硬件的基本结构
3. 计算机软件和硬件的关系
4. 计算机系统的工作原理

"[存储程序](https://zhida.zhihu.com/search?content_id=252070749&content_type=Article&match_order=1&q=%E5%AD%98%E5%82%A8%E7%A8%8B%E5%BA%8F&zhida_source=entity)"工作方式

高级语言程序与机器语言程序之间的转换

程序和指令的执行过程。

(二) 计算机性能指标

1. 吞吐量、响应时间
2. CPU时钟周期、主频、CPI、CPU执行时间
3. MIPS、MFLOPS、GFLOPS、TFLOPS、PFLOPS、EFLOPS、ZFLOPS

**第二章 数据的表示和运算**

(一) 数制与编码

1. 进位计数制及其数据之间的相互转换
2. 定点数的编码表示

(二) 运算方法和运算电路

基本运算部件:加法器，算术逻辑部件(ALU) 、加/减运算:[补码加/减运算器](https://zhida.zhihu.com/search?content_id=252070749&content_type=Article&match_order=1&q=%E8%A1%A5%E7%A0%81%E5%8A%A0/%E5%87%8F%E8%BF%90%E7%AE%97%E5%99%A8&zhida_source=entity)，标志位的生成、乘/除运算:乘/除法运算的基本原理，乘法电路和除法电路的基本结构

(三) 整数的表示和运算

1. 无符号整数的表示和运算
2. 带符号整数的表示和运算

(四) 浮点数的表示和运算

1. 浮点数的表示:IEEE 754标准
2. 浮点数的加/减运算

**第三章 存储器层次结构**

(一) 存储器的分类

(二) 层次化存储器的基本结构

(三) 半导体随机存取存储器

1. [SRAM存储器](https://zhida.zhihu.com/search?content_id=252070749&content_type=Article&match_order=1&q=SRAM%E5%AD%98%E5%82%A8%E5%99%A8&zhida_source=entity)
2. [DRAM存储器](https://zhida.zhihu.com/search?content_id=252070749&content_type=Article&match_order=1&q=DRAM%E5%AD%98%E5%82%A8%E5%99%A8&zhida_source=entity)
3. [Flash存储器](https://zhida.zhihu.com/search?content_id=252070749&content_type=Article&match_order=1&q=Flash%E5%AD%98%E5%82%A8%E5%99%A8&zhida_source=entity)

(四) 主存储器

1. DRAM芯片和内存条
2. 多模块存储器
3. 主存和CPU之间的连接

(五) 外部存储器

1. 磁盘存储器
2. 固态硬盘(SSD)

(六) 高速缓冲存储器(Cache)

1. Cache的基本原理
2. Cache和主存之间的映射方式
3. Cache中主存块的替换算法
4. [Cache写策略](https://zhida.zhihu.com/search?content_id=252070749&content_type=Article&match_order=1&q=Cache%E5%86%99%E7%AD%96%E7%95%A5&zhida_source=entity)

(七) [虚拟存储器](https://zhida.zhihu.com/search?content_id=252070749&content_type=Article&match_order=1&q=%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8&zhida_source=entity)

1. 虚拟存储器的基本概念
2. [页式虚拟存储器](https://zhida.zhihu.com/search?content_id=252070749&content_type=Article&match_order=1&q=%E9%A1%B5%E5%BC%8F%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8&zhida_source=entity):基本原理，页表，地址转换，TLB(快表)
3. [段式虚拟存储器](https://zhida.zhihu.com/search?content_id=252070749&content_type=Article&match_order=1&q=%E6%AE%B5%E5%BC%8F%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8&zhida_source=entity)的基本原理
4. [段页式虚拟存储器](https://zhida.zhihu.com/search?content_id=252070749&content_type=Article&match_order=1&q=%E6%AE%B5%E9%A1%B5%E5%BC%8F%E8%99%9A%E6%8B%9F%E5%AD%98%E5%82%A8%E5%99%A8&zhida_source=entity)的基本原理

**第四章 指令系统**

(一) 指令系统的基本概念

(二) 指令格式

(三) 寻址方式

(四) 数据的对齐和大/小端存放方式

(五) [CISC和RISC](https://zhida.zhihu.com/search?content_id=252070749&content_type=Article&match_order=1&q=CISC%E5%92%8CRISC&zhida_source=entity)的基本概念

(六) 高级语言程序与机器级代码之间的对应

1. 编译器，汇编器和链路器的基本概念
2. 选择结构语句的机器级表示
3. 循环结构语句的机器级表示
4. 过程(函数) 调用对应的机器级表示

**第五章 中央处理器**

(一) CPU的功能和基本结构

(二) 指令执行过程

(三) 数据通路的功能和基本结构

(四) 控制器的功能和工作原理

(五) 异常和中断机制

1. 异常和中断的基本概念
2. 异常和中断的分类
3. 异常和中断的检测与响应

(六) [指令流水线](https://zhida.zhihu.com/search?content_id=252070749&content_type=Article&match_order=1&q=%E6%8C%87%E4%BB%A4%E6%B5%81%E6%B0%B4%E7%BA%BF&zhida_source=entity)

1. 指令流水线的基本概念
2. 指令流水线的基本实现
3. 结构冒险、数据冒险和控制冒险的处理
4. 超标量和动态流水线的基本概念

(七) [多处理器基本概念](https://zhida.zhihu.com/search?content_id=252070749&content_type=Article&match_order=1&q=%E5%A4%9A%E5%A4%84%E7%90%86%E5%99%A8%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5&zhida_source=entity)

1. SISDLSIMD、MIMD、向量处理器的基本概念
2. 硬件多线程的基本概念
3. 多核处理器(multi-core) 的基本概念
4. 共享内存多处理器(SMP) 的基本概念

**第六章 总线**

(一) 总线

1. 总线的基本概念
2. 总线的组成及性能指标
3. [总线事务和定时](https://zhida.zhihu.com/search?content_id=252070749&content_type=Article&match_order=1&q=%E6%80%BB%E7%BA%BF%E4%BA%8B%E5%8A%A1%E5%92%8C%E5%AE%9A%E6%97%B6&zhida_source=entity)

(二) [I/O](https://zhida.zhihu.com/search?content_id=252070749&content_type=Article&match_order=1&q=I/O%E6%8E%A5%E5%8F%A3&zhida_source=entity)接口(I/O控制器）

1. [I/O接口](https://zhida.zhihu.com/search?content_id=252070749&content_type=Article&match_order=1&q=I/O%E6%8E%A5%E5%8F%A3&zhida_source=entity)的功能和基本结构
2. [I/O](https://zhida.zhihu.com/search?content_id=252070749&content_type=Article&match_order=1&q=I/O%E6%8E%A5%E5%8F%A3&zhida_source=entity)端口及其编址

(三) I/O方式

1. [程序查询方式](https://zhida.zhihu.com/search?content_id=252070749&content_type=Article&match_order=1&q=%E7%A8%8B%E5%BA%8F%E6%9F%A5%E8%AF%A2%E6%96%B9%E5%BC%8F&zhida_source=entity)
2. [程序中断方式](https://zhida.zhihu.com/search?content_id=252070749&content_type=Article&match_order=1&q=%E7%A8%8B%E5%BA%8F%E4%B8%AD%E6%96%AD%E6%96%B9%E5%BC%8F&zhida_source=entity)  
   中断的基本概念  
   中断响应过程  
   中断处理过程  
   多重中断和中断屏蔽的概念
3. [DMA方式](https://zhida.zhihu.com/search?content_id=252070749&content_type=Article&match_order=1&q=DMA%E6%96%B9%E5%BC%8F&zhida_source=entity)

DMA控制器的组成

DMA传送过程

# 9 REF

- 王道书、网课
- 计组很详细，我结合网课ppt做了补充：[GitHub - LYuYang61/408: 计算机考研408笔记](https://github.com/LYuYang61/408/tree/master)
- [Site Unreachable](https://zhuanlan.zhihu.com/p/29581993134)

![](/static/images/blog/2025/408-co/Pasted%20image%2020250717164603.webp)
